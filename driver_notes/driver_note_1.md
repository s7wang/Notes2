# Linux 设备驱动

# 第一章 设备驱动简介

本书指导你如何编写你自己的驱动, 以及如何利用内核相关的部分. 我们采用一种设备-独立的方法;
编程技术和接口, 在任何可能的时候, 不会捆绑到任何特定的设备. 每一个驱动都是不同的; 作为一个
驱动编写者, 你需要深入理解你的特定设备. 但是大部分的原则和基本技术对所有驱动都是一样的. 本
书无法教你关于你的设备的东西, 但是它给予你所需要的使你的设备运行起来的背景知识的指导。



## 1.1 驱动程序的角色

个驱动程序的角色是提供机制, 而不是策略。机制和策略的区分是其中一个在 Unix 设计背后的最好观念. 大部分的编程问题其实可以划分为 2 部分：

* " 提供什么能力"(机制) 
* "如何使用这些能力"(策略)

 如果这两方面由程序的不同部分来表达, 或者甚至由不同的程序共同表达, 软件包是非常容易开发和适应特殊的需求。

在编写驱动时, 程序员应当特别注意这个基础的概念: 编写内核代码来存取硬件, 但是不能强加特别的策略给用户, 因为不同的用户有不同的需求. 驱动应当做到使硬件可用, 将所有关于如何使用硬件的事情留给应用程序。一个驱动,这样就是灵活的, 如果它提供了对硬件能力的存取, 没有增加约束. 然而, 有时必须作出一些策略的决定. 例如, 一个数字 I/O 驱动也许只提供对硬件的字符存取, 以便避免额外的代码处理单个位。

在编写驱动时, 程序员应当特别注意这个基础的概念: 编写内核代码来存取硬件, 但是不能强加特别的策略给用户, 因为不同的用户有不同的需求.。驱动应当做到使硬件可用, 将所有关于如何使用硬件的事情留给应用程序。一个驱动, 这样, 就是灵活的, 如果它提供了对硬件能力的存取, 没有增加约束. 然而, 有时必须作出一些策略的决定。例如, 一个数字 I/O 驱动也许只提供对硬件的字符存取, 以便避免额外的代码处理单个位。



## 1.2 划分内核

在 Unix 系统中, 几个并发的进程专注于不同的任务. 每个进程请求系统资源, 象计算能力, 内存, 网络连接, 或者一些别的资源. 内核是个大块的可执行文件, 负责处理所有这样的请求. 尽管不同内核任务间的区别常常不是能清楚划分, 内核的角色可以划分成下列几个部分:

* 进程管理

> 内核负责创建和销毁进程, 并处理它们与外部世界的联系(输入和输出)。不同进程间通讯(通过信号, 管道, 或者进程间通讯原语)对整个系统功能来说是基本的, 也由内核处理。另外, 调度器, 控制进程如何共享 CPU, 是进程管理的一部分。更通常地, 内核的进程管理活动实现了多个进程在一个单个或者几个 CPU 之上的抽象。

* 内存管理

> 计算机的内存是主要的资源, 处理它所用的策略对系统性能是至关重要的。内核为所有进程的每一个都在有限的可用资源上建立了一个虚拟地址空间。内核的不同部分与内存管理子系统通过一套函数调用交互, 从简单的 malloc/free 对到更多更复杂的功能。

* 文件系统

> Unix 在很大程度上基于文件系统的概念; 几乎 Unix 中的任何东西都可看作一个文件。内核在非结构化的硬件之上建立了一个结构化的文件系统, 结果是文件的抽象非常多地在整个系统中应用。另外, Linux 支持多个文件系统类型, 就是说, 物理介质上不同的数据组织方式。例如, 磁盘可被格式化成标准 Linux 的 ext3 文件系统, 普遍使用的 FAT 文件系统, 或者其他几个文件系统。

* 设备控制

> 几乎每个系统操作最终都映射到一个物理设备上。除了处理器, 内存和非常少的别的实体之外, 全部中的任何设备控制操作都由特定于要寻址的设备相关的代码来进行。这些代码称为设备驱动。内核中必须嵌入系统中出现的每个外设的驱动, 从硬盘驱动到键盘和磁带驱动器。内核功能的这个方面是本书中的我们主要感兴趣的地方。

* 网络

> 网络必须由操作系统来管理, 因为大部分网络操作不是特定于某一个进程: 进入系统的报文是异步事件。报文在某一个进程接手之前必须被收集, 识别, 分发。系统负责在程序和网络接口之间递送数据报文, 它必须根据程序的网络活动来控制程序的执行。另外, 所有的路由和地址解析问题都在内核中实现。



### 1.2.1 可加载模块

Linux 的众多优良特性之一就是可以在运行时扩展由内核提供的特性的能力。这意味着你可以在系统正在运行着的时候增加内核的功能( 也可以去除 )。

每块可以在运行时添加到内核的代码, 被称为一个模块。Linux 内核提供了对许多模块类型的支持, 包括但不限于, 设备驱动。每个模块由目标代码组成( 没有连接成一个完整可执行文件 ), 可以动态连接到运行中的内核中, 通过insmod 程序, 以及通过 rmmod 程序去连接。



## 1.3 设备和模块分类

以 Linux 的方式看待设备可区分为 3 种基本设备类型。每个模块常常实现 3 种类型中的 1 种, 因此可分类成字符模块, 块模块, 或者一个网络模块。这种将模块分成不同类型或类别的方法并非是固定不变的; 程序员可以选择建立在一个大块代码中实现了不同驱动的巨大模块。但是, 好的程序员, 常常创建一个不同的模块给每个它们实现的新功能,因为分解是可伸缩性和可扩张性的关键因素。

三类驱动如下：

* 字符设备

> 一个字符( char ) 设备是一种可以当作一个字节流来存取的设备( 如同一个文件 ); 一个字符驱动负责实现这种行为。这样的驱动常常至少实现 open, close,read, 和 write 系统调用。文本控制台( /dev/console )和串口( /dev/ttyS0 及其友 )是字符设备的例子, 因为它们很好地展现了流的抽象。字符设备通过文件系统结点来存取, 例如 /dev/tty1 和 /dev/lp0。在一个字符设备和一个普通文件之间唯一有关的不同就是, 你经常可以在普通文件中移来移去, 但是大部分字符设备仅仅是数据通道, 你只能顺序存取。然而, 存在看起来象数据区的字符设备, 你可以在里面移来移去。例如, frame grabber 经常这样, 应用程序可以使用 mmap 或者 lseek 存取整个要求的图像。

* 块设备

> 如同字符设备, 块设备通过位于 /dev 目录的文件系统结点来存取。一个块设备(例如一个磁盘)应该是可以驻有一个文件系统的。在大部分的 Unix 系统, 一个块设备只能处理这样的 I/O 操作, 传送一个或多个长度经常是 512 字节( 或一个更大的 2 的幂的数 )的整块。Linux, 相反, 允许应用程序读写一个块设备象一个字符设备一样 -- 它允许一次传送任意数目的字节。结果就是, 块和字符设备的区别仅仅在内核在内部管理数据的方式上, 并且因此在内核/驱动的软件接口上不同.如同一个字符设备, 每个块设备都通过一个文件系统结点被存取的, 它们之间的区别对用户是透明的。块驱动和字符驱动相比, 与内核的接口完全不同。

* 网络接口

> 任何网络事务都通过一个接口来进行, 就是说, 一个能够与其他主机交换数据的设备。通常, 一个接口是一个硬件设备, 但是它也可能是一个纯粹的软件设备, 比如环回接口。一个网络接口负责发送和接收数据报文, 在内核网络子系统的驱动下,不必知道单个事务是如何映射到实际的被发送的报文上的。很多网络连接( 特别那些使用 TCP 的)是面向流的, 但是网络设备却常常设计成处理报文的发送和接收。一个网络驱动对单个连接一无所知;它只处理报文。
>
> 既然不是一个面向流的设备, 一个网络接口就不象 /dev/tty1 那么容易映射到文件系统的一个结点上。 Unix 提供的对接口的存取的方式仍然是通过分配一个名子给它们( 例如 eth0 ), 但是这个名子在文件系统中没有对应的入口。内核与网络设备驱动间的通讯与字符和块设备驱动所用的完全不同. 不用 read 和 write, 内核调用和报文传递相关的函数。

在设备驱动之外, 别的功能, 不论硬件和软件, 在内核中都是模块化的。一个普通的例子是文件系统。一个文件系统类型决定了在块设备上信息是如何组织的, 以便能表示一棵目录与文件的树。这样的实体不是设备驱动, 因为没有明确的设备与信息摆放方式相联系;文件系统类型却是一种软件驱动, 因为它将低级数据结构映射为高级的数据结构。文件系统决定一个文件名多长, 以及在一个目录入口中存储每个文件的什么信息. 文件系统模块必须实现最低级的系统调用, 来存取目录和文件, 通过映射文件名和路径( 以及其他信息,例如存取模式 )到保存在数据块中的数据结构。这样的一个接口是完全与数据被传送来去磁盘( 或其他介质 )相互独立, 这个传送是由一个块设备驱动完成的。如果你考虑一个 Unix 系统是多么依赖下面的文件系统, 你会认识到这样的一个软件概念对系统操作是至关重要的.。解码文件系统信息的能力处于内核层级中最低级, 并且是最重要的; 甚至如果你为你的新 CD-ROM 编写块驱动, 如果你对上面的数据不能运行 ls 或者cp 就毫无用处。Linux 支持一个文件系统模块的概念, 其软件接口声明了不同操作, 可以在一个文件系统节点, 目录, 文件和超级块上进行操作。对一个程序员来说, 居然需要编写一个文件系统模块是非常不常见的, 因为官方内核已经包含了大部分重要的文件系统类型的代码。



## 1.4 安全问题

系统中任何安全检查都由内核代码强加上去。如果内核有安全漏洞, 系统作为一个整体就有漏洞。在官方的内核发布里, 只有一个有授权的用户可以加载模块; 系统调用init_module 检查调用进程是否是有权加载模块到内核里。因此, 当运行一个官方内核时,只有超级用户或者一个成功获得特权的入侵者, 才可以利用特权代码的能力。

在可能时, 驱动编写者应当避免将安全策略编到他们的代码中。安全是一个策略问题, 最好在内核高层来处理, 在系统管理员的控制下。但是, 常有例外。作为一个设备驱动编写者, 你应当知道在什么情形下, 某些类型的设备存取可能反面地影响系统作为一个整体, 并且应当提供足够地控制。例如, 会影响全局资源的设备操作( 例如设置一条中断线 ), 可能会损坏硬件( 例如, 加载固件 ), 或者它可能会影响其他用户( 例如设置一个磁带驱动的缺省的块大小 ), 常常是只对有足够授权的用户, 并且这种检查必须由驱动自身进行。

驱动编写者也必须要小心, 当然, 来避免引入安全 bug。C 编程语言使得易于犯下几类的错误。例如, 许多现今的安全问题是由于缓冲区覆盖引起, 它是由于程序员忘记检查有多少数据写入缓冲区, 数据在缓冲区结尾之外结束, 因此覆盖了无关的数据。这样的错误可能会危及整个系统的安全, 必须避免. 幸运的是, 在设备驱动上下文中避免这样的错误经常是相对容易的, 这里对用户的接口经过精细定义并被高度地控制。















