# Linux 设备驱动

# 第二章 建立和运行模块

时间差不多该开始编程了. 本章介绍所有的关于模块和内核编程的关键概念.。在这几页里, 我们建立并运行一个完整(但是相对地没有什么用处)的模块, 并且查看一些被所有模块共用的基本代码。开发这样的专门技术对任何类型的模块化的驱动都是重要的基础。为避免一次抛出太多的概念, 本章只论及模块,不涉及任何特别的设备类型。



## 2.1 设置你的测试系统

不管你的内核来源, 建立 2.6.x 的模块需要你有一个配置好并建立好的内核树在你的系统中。 这个要求是从之前内核版本的改变, 之前只要有一套当前版本的头文件就足够了。2.6模块针对内核源码树里找到的目标文件连接; 结果是一个更加健壮的模块加载器, 还要求那些目标文件也是可用的。因此你的第一个商业订单是具备一个内核源码树( 或者从krenel.org 网络或者你的发布者的内核源码包), 建立一个新内核, 并且安装到你的系统。

我这里使用的是win10-wsl2-ubuntu22.02

~~~(空)
 uname -a
Linux DESKTOP-WANGS7 6.6.87.2-microsoft-standard-WSL2 #1 SMP PREEMPT_DYNAMIC Thu Jun  5 18:30:46 UTC 2025 x86_64 x86_64 x86_64 GNU/Linux
~~~



## 2.2 Hello World 模块

由于WSL2为微软定制内核本身不支持编译/运行本机内核模块，所以使用交叉编译，使用win10-wsl2-ubuntu22.02为编译主机，VMware-ubuntu18.04为目标主机

~~~(空)
uname -a # 编译主机
Linux DESKTOP-WANGS7 6.6.87.2-microsoft-standard-WSL2 #1 SMP PREEMPT_DYNAMIC Thu Jun  5 18:30:46 UTC 2025 x86_64 x86_64 x86_64 GNU/Linux
~~~

~~~(空)
 uname -a # 目标主机
Linux h3cw32336 5.4.0-150-generic #167~18.04.1-Ubuntu SMP Wed May 24 00:51:42 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux
~~~

编译环境构建：

~~~(空)
# 目标主机

cd /usr/src
sudo tar -czf kernel_headers_5.4.0-150.tar.gz  \
linux-headers-5.4.0-150-generic \
linux-hwe-5.4-headers-5.4.0-150

# 编译主机
mkdir -p kernel_headers/5.4.0-150                                                     
tar -xzf kernel_headers_5.4.0-150.tar.gz -C kernel_headers/5.4.0-150 
~~~

hello_world_kmod：

~~~
.
├── HelloWorld
│   ├── Makefile
│   └── hello_world_kmod.c
├── Makefile
└── README.md
~~~

~~~c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("GG GG");
MODULE_DESCRIPTION("A simple Hello World kernel module");
MODULE_VERSION("0.1");

// 模块初始化函数
static int __init hello_init(void) {
    printk(KERN_INFO "Hello, world! Module loaded.\n");
    return 0;
}

// 模块卸载函数
static void __exit hello_exit(void) {
    printk(KERN_INFO "Goodbye, world! Module unloaded.\n");
}

module_init(hello_init);
module_exit(hello_exit);

~~~

~~~~makefile
# HelloWord/Makefile
# 目标模块名：hello_world_kmod.ko
obj-m := hello_world_kmod.o

# KDIR 指向当前运行内核的头文件目录
KDIR := $(HOME)/Github/kernel_headers/5.4.0-150/linux-headers-5.4.0-150-generic

# 当前模块所在目录
PWD := $(shell pwd)

all:
	$(MAKE) -C $(KDIR) M=$(PWD) modules

clean:
	$(MAKE) -C $(KDIR) M=$(PWD) clean
~~~~

编译后copy到宿主机中：

~~~(空)
# dmesg -w 监视log
# sudo insmod hello_world_kmod.ko 后
[ 3019.379177] Hello, world! Module loaded.
# sudo rmmod hello_world_kmod.ko 后
[ 3032.804443] Goodbye, world! Module unloaded.

# sudo inmod hello_world_kmod.ko后 sudo rmmod hello_world_kmod.ko 前
# 执行 lsmod | grep hello
hello_world_kmod       16384  0
# sudo rmmod hello_world_kmod.ko 后 
无输出
~~~

这个模块定义了两个函数, 一个在模块加载到内核时被调用( hello_init )以及一个在模块被去除时被调用( hello_exit )。 moudle_init 和 module_exit 这几行使用了特别的内核宏来指出这两个函数的角色。另一个特别的宏 MODULE_LICENSE) 是用来告知内核, 该模块带有一个自由的许可证; 没有这样的说明, 在模块加载时内核会抱怨。
printk 函数在 Linux 内核中定义并且对模块可用; 它与标准 C 库函数 printf 的行为相似。内核需要它自己的打印函数, 因为它靠自己运行, 没有 C 库的帮助. 模块能够调用printk 是因为, 在 insmod 加载了它之后, 模块被连接到内核并且可存取内核的公用符号(函数和变量, 下一节详述). 字串 KERN_INFO 是消息的优先级。

每个宏的作用如下：

1. **MODULE_LICENSE**

这个宏用于指定模块的许可证类型。在这里，`"GPL"` 表示该模块遵循 GNU 通用公共许可证（General Public License）。这对于内核模块来说非常重要，因为它会影响模块的加载方式以及是否会导致内核模块被拒绝加载。

- 作用：
  - 明确标明模块遵循的许可证，通常是为了保证代码的开源性。
  - 如果没有指定许可证或者指定为不兼容的许可证（如 `proprietary`），内核会拒绝加载该模块（出于与内核许可证一致性的考虑）。
  - `GPL` 表示模块源代码可以自由使用、修改和分发。

2. **MODULE_AUTHOR**

该宏用于指定模块的作者，可以是个人或组织的名称。它提供了模块的作者信息，便于他人了解模块的开发者。

- 作用：
  - 标识模块的作者，通常是开发该模块的开发者或团队。
  - 这个信息通常会出现在内核日志和一些调试信息中，用于追溯模块的开发者。

3. **MODULE_DESCRIPTION**

该宏用于提供模块的简短描述信息。这个描述应该清晰地说明模块的功能。

- 作用：
  - 给出模块的简要说明，便于其他开发者或者用户了解模块的用途。
  - 在内核日志中，加载或卸载模块时会显示此描述。

4. **MODULE_VERSION**

该宏用于指定模块的版本号。它帮助标识模块的版本，通常在模块的开发过程中非常有用。

- 作用：
  - 提供模块的版本信息，可以帮助开发者区分不同版本的模块。
  - 在调试和维护中，这个版本号可以帮助确定模块的改动历史。
  - 在加载模块时，内核也会显示此版本号，便于进行版本跟踪。



## 2.3 内核模块相比于应用程序

不同于大部分的小的和中型的应用程序从头至尾处理一个单个任务, 每个内核模块只注册自己以便来服务将来的请求, 并且它的初始化函数立刻终止。换句话说, 模块初始化函数的任务是为以后调用模块的函数做准备; 好像是模块说, " 我在这里, 这是我能做的。"模块的退出函数( 例子里是 hello_exit )就在模块被卸载时调用. 它好像告诉内核, "我不再在那里了, 不要要求我做任何事了。"这种编程的方法类似于事件驱动的编程, 但是虽然不是所有的应用程序都是事件驱动的, 每个内核模块都是.。

另外一个主要的不同, 在事件驱动的应用程序和内核代码之间, 是退出函数: 一个终止的应用程序可以在释放资源方面懒惰, 或者完全不做清理工作, ==但是模块的退出函数必须小心恢复每个由初始化函数建立的东西, 否则会保留一些东西直到系统重启。==

卸载模块的能力是你将最欣赏的模块化的其中一个特色, 因为它有助于减少开发时间; 你可测试你的新驱动的连续的版本, 而不用每次经历漫长的关机/重启周期。

一个应用程序可以调用它没有定义的函数:连接阶段使用合适的函数库解决了外部引用。printf 是一个这种可调用的函数并且在 libc 里面定义. 一个模块, 在另一方面, 只连接到内核, 它能够调用的唯一的函数是内核输出的那些; 没有库来连接。在 hello.c 中使用的 printk 函数。例如, 是在内核中定义的 printf 版本并且输出给模块。它表现类似于原始的函数, 只有几个小的不同, **首要的一个是缺乏浮点的支持**。

因为没有库连接到模块中, 源文件不应当包含通常的头文件, <stdarg.h>和非常特殊的情况是仅有的例外。只有实际上是内核的一部分的函数才可以在内核模块里使用。内核相关的任何东西都在头文件里声明, 这些头文件在你已建立和配置的内核源码树里; 大部分相关的头文件位于 include/linux 和 include/asm, 但是别的 include 的子目录已经添加到关联特定内核子系统的材料里了。单个内核头文件的作用在书中需要它们的时候进行介绍。

另外一个在内核编程和应用程序编程之间的重要不同是每一个环境是如何处理错误: 在应用程序开发中段错误是无害的, 一个调试器常常用来追踪错误到源码中的问题, 而一个内核错误至少会杀掉当前进程, 如果不终止整个系统。

### 2.3.1 用户空间和内核空间

**A module runs in kernel space, whereas applications run in user space. This concept is at**
**the base of operating systems theory.**

**一个模块在内核空间运行, 而应用程序在用户空间运行. 这个概念是操作系统理论的基础。**

操作系统的角色, 实际上, 是给程序提供一个一致的计算机硬件的视角。另外, 操作系统必须承担程序的独立操作和保护对于非授权的资源存取。这一不平凡的任务只有 CPU 增强系统软件对应用程序的保护才有可能。

每种现代处理器都能够加强这种行为。 选中的方法是 CPU 自己实现不同的操作形态(或者级别)。 这些级别有不同的角色, 一些操作在低些级别中不允许; 程序代码只能通过有限的几个门从一种级别切换到另一个。Unix 系统设计成利用了这种硬件特性, 使用了两个这样的级别。所有当今的处理器至少有两个保护级别, 并且某些, 例如 x86 家族, 有更多级别;当几个级别存在时, 使用最高和最低级别。 在 Unix 下, 内核在最高级运行( 也称之为超级模式 ), 这里任何事情都允许, 而应用程序在最低级运行(所谓的用户模式), 这里处理器控制了对硬件的直接存取以及对内存的非法存取。

我们常常提到运行模式作为**内核空间**和**用户空间**。这些术语不仅包含存在于这两个模式中不同特权级别, 还包含有这样的事实, 即每个模式有它自己的内存映射 -- 它自己的地址空间。

Unix 从用户空间转换执行到内核空间, 无论何时一个应用程序发出一个系统调用或者被硬件中断挂起时。执行系统调用的内核代码在进程的上下文中工作 -- 它代表调用进程并且可以存取该进程的地址空间。换句话说, 处理中断的代码对进程来说是异步的, 不和任何特别的进程有关。

模块的角色是扩展内核的功能; 模块化的代码在内核空间运行。经常地一个驱动进行之前提到的两种任务: 模块中**一些的函数作为系统调用的一部分执行**, **一些负责中断处理**。



### 2.3.2 内核的并发

内核编程与传统应用程序编程方式很大不同的是并发问题。大部分应用程序, 多线程的应用程序是一个明显的例外, 典型地是顺序运行的, 从头至尾, 不必要担心其他事情会发生而改变它们的环境。内核代码没有运行在这样的简单世界中, 即便最简单的内核模块必须在这样的概念下编写, 很多事情可能马上发生。

内核编程中有几个并发的来源。自然的, Linux 系统运行多个进程, 在同一时间, 不止一个进程能够试图使用你的驱动。大部分设备能够中断处理器; 中断处理异步运行, 并且可能在你的驱动试图做其他事情的同一时间被调用。几个软件抽象( 例如内核定时器, 第 7章介绍 )也异步运行。而且, 当然, Linux 可以在对称多处理器系统( SMP )上运行, 结果是你的驱动可能在多个 CPU 上并发执行。最后, 在 **2.6, 内核代码已经是可抢占的了; 这个变化使得即便是单处理器会有许多与多处理器系统同样的并发问题**。

==结果, Linux 内核代码, 包括驱动代码, 必须是可重入的 -- 它必须能够同时在多个上下文中运行==。数据结构必须小心设计以保持多个执行线程分开, 并且代码必须小心存取共享数据, 避免数据的破坏。编写处理并发和避免竞争情况( 一个不幸的执行顺序导致不希望的行为的情形 )的代码需要仔细考虑并可能是微妙的。**正确的并发管理在编写正确的内核代码时是必须的**; 由于这个理由, 本书的每一个例子驱动都是考虑了并发下编写的。用到的技术在我们遇到它们时再讲解; 第 5 章也专门讲述这个问题, 以及并发管理的可用的内核原语。

驱动程序员的一个通常的错误是假定并发不是一个问题, 只要一段特别的代码没有进入睡眠( 或者 "阻塞" )。即便在之前的内核( 不可抢占), 这种假设在多处理器系统中也不成立。在 2.6, 内核代码不能(极少)假定它能在一段给定代码上持有处理器。如果你不考虑并发来编写你的代码, 就极有可能导致严重失效, 以至于非常难于调试。



### 2.3.3 当前进程

尽管内核模块不象应用程序一样顺序执行, 内核做的大部分动作是代表一个特定进程的。内核代码可以引用当前进程, 通过存取全局项 current, 它在 <asm/current.h> 中定义,它产生一个指针指向结构 task_struct, 在 <linux/sched.h> 定义。current 指针指向当前在运行的进程。在一个系统调用执行期间, 例如 open 或者 read, 当前进程是发出调用的进程。内核代码可以通过使用 current 来使用进程特定的信息, 如果它需要这样。 这种
技术的一个例子在第 6 章展示.

实际上, current 不真正地是一个全局变量。支持 SMP 系统的需要强迫内核开发者去开发一种机制, 在相关的 CPU 上来找到当前进程。 这种机制也必须快速, 因为对 current 的引用非常频繁地发生。 结果就是一个依赖体系的机制, 常常, 隐藏了一个指向task_struct 的指针在内核堆栈内。实现的细节对别的内核子系统保持隐藏, 一个设备驱
动可以只包含 <linux/sched.h> 并且引用当前进程。例如, 下面的语句打印了当前进程的进程 ID 和命令名称, 通过存取结构 task_struct 中的某些字段。

~~~c
printk(KERN_INFO "The process is \"%s\" (pid %i)\n", current->comm, current->pid);
~~~

存于 current->comm 的命令名称是由当前进程执行的程序文件的基本名称( 截短到 15 个字符, 如果需要 )。

简单的实验案例

~~~c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/sched.h>  // 包含 task_struct 和 current

MODULE_LICENSE("GPL");
MODULE_AUTHOR("GG GG");
MODULE_DESCRIPTION("Kernel module to print current process information");
MODULE_VERSION("0.1");

static int __init get_pid_kmod_init(void)
{
    printk(KERN_INFO "The process is \"%s\" (pid %i)\n", current->comm, current->pid);
    return 0;
}

static void __exit get_pid_kmod_exit(void)
{
    printk(KERN_INFO "Goodbye from get_pid_kmod\n");
}

module_init(get_pid_kmod_init);
module_exit(get_pid_kmod_exit);
~~~

~~~(空)
# sudo insmod get_pid_kmod.ko 后
[14696.414913] The process is "insmod" (pid 11983)
# sudo rmmod get_pid_kmod.ko 后
[14720.304069] Goodbye from get_pid_kmod
~~~



### 2.3.4 几个特别的细节

内核编程与用户空间编程在许多方面不同。我们将在本书的过程中指出它们, 但是有几个基础性的问题, 尽管没有保证它们自己有一节内容, 也值得一提。因此, 当你深入内核时,下面的事项应当牢记。

* **节省空间**

应用程序存在于虚拟内存中, 有一个非常大的堆栈区。当然, 堆栈是用来保存函数调用历史以及所有的由当前活跃的函数创建的自动变量。内核, 相反, 有一个非常小的堆栈;它可能小到一个, 4096 字节的页。你的函数必须与这个内核空间调用链共享这个堆栈。因此, 声明一个巨大的自动变量从来就不是一个好主意; 如果你需要大的结构, 你应当在调用时间内动态分配。

* **小心调用“__xxx”双下划线开头的函数**

常常, 当你查看内核 API 时, 你会遇到以双下划线(`__`)开始的函数名。**这样标志的函数名通常是一个低层的接口组件, 应当小心使用。**本质上讲, 双下划线告诉程序员:" 如果你调用这个函数, 确信你知道你在做什么。"

* **内核代码不能使用浮点运算**

内核代码不能做浮点算术。使能浮点将要求内核在每次进出内核空间的时候保存和恢复浮点处理器的状态 -- 至少, 在某些体系上。在这种情况下, 内核代码真的没有必要包含浮点, 额外的负担不值得。



## 2.4 编译和加载

本章开头的 "hello world" 例子包含了一个简短的建立并加载模块到系统中去的演示。当然, 整个过程比我们目前看到的多。本节提供了更多细节关于一个模块作者如何将源码转换成内核中的运行的子系统。

### 2.4.1 编译模块

第一步, 我们需要看一下模块如何必须被建立。模块的建立过程与用户空间的应用程序的建立过程有显著不同; 内核是一个大的, 独立的程序, 对于它的各个部分如何组合在一起有详细的明确的要求。建立过程也与以前版本的内核的过程不同; 新的建立系统用起来更简单并且产生更正确的结果, 但是它看起来与以前非常不同。内核建立系统是一头负责的野兽, 我们就看它一小部分。在内核源码的 Document/kbuild 目录下发现的文件, 任何想理解表面之下的真实情况的人都要阅读一下。

有几个前提, 你必须在能建立内核模块前解决。第一个是保证你有版本足够新的编译器,模块工具, 以及其他必要工具. 在内核文档目录下的文件 Documentation/Changes 一直列出了需要的工具版本; 你应当在向前走之前参考一下它。试图建立一个内核(包括它的模块), 用错误的工具版本, 可能导致不尽的奇怪的难题。**注意, 偶尔地, 编译器的版本太新可能会引起和太老的版本引起的一样的问题。内核源码对于编译器做了很大的假设, 新的发行版本有时会一时地破坏东西。**

如果你仍然没有一个内核树在手边, 或者还没有配置和建立内核, 现在是时间去做了。没有源码树在你的文件系统上, 你无法为 2.6 内核建立可加载的模块。实际运行为其而建立的内核也是有帮助的( 尽管不是必要的 。

一旦你已建立起所有东西, 给你的模块创建一个 makefile 就是直截了当的。实际上, 对于本章前面展示的" hello world" 例子, 单行就够了:

~~~makefile
obj-m := hello_world_kmod.o
~~~

熟悉 make , 但是对 2.6 内核建立系统不熟悉的读者, 可能奇怪这个 makefile 如何工作。毕竟上面的这一行不是一个传统的 makefile 的样子。答案, 当然, 是内核建立系统处理了余下的工作。（或者像我的案例一样自己配置其他参数和动作）上面的安排( 它利用了由 GNU make 提供的扩展语法 )表明有一个模块要从目标文件 hello_world_kmod.o 建立. 在从目标文件建立后结果模块命名为 hello_world_kmod.ko。

反之, 如果你有一个模块名为 module.ko, 是来自 2 个源文件( 姑且称之为, file1.c 和 file2.c ), 正确的书写应当是:

~~~makefile
obj-m := module.o
module-objs := file1.o file2.o
~~~

对于一个象上面展示的要工作的 makefile, 它必须在更大的内核建立系统的上下文被调用。如果你的内核源码数位于, 假设, 你的 ~/kernel-2.6 目录, 用来建立你的模块的 make命令( 在包含模块源码和 makefile 的目录下键入 )会是:

~~~makefile
make -C ~/kernel-2.6 M=`pwd` modules
# 类似的在我使用的wsl2环境中需要使用：
# $(MAKE) -C $(KDIR) M=$(PWD) modules
~~~

这个命令开始是改变它的目录到用 -C 选项提供的目录下( 就是说, 你的内核源码目录 )。它在那里会发现内核的顶层 makefile。 这个 M= 选项使 makefile 在试图建立模块目标前,回到你的模块源码目录。这个目标, 依次地, 是指在 obj-m 变量中发现的模块列表, 在我们的例子里设成了 module.o。



### 2.4.2 加载和卸载模块











