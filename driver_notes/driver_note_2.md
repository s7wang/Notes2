# Linux 设备驱动

# 第二章 建立和运行模块

时间差不多该开始编程了. 本章介绍所有的关于模块和内核编程的关键概念.。在这几页里, 我们建立并运行一个完整(但是相对地没有什么用处)的模块, 并且查看一些被所有模块共用的基本代码。开发这样的专门技术对任何类型的模块化的驱动都是重要的基础。为避免一次抛出太多的概念, 本章只论及模块,不涉及任何特别的设备类型。



## 2.1 设置你的测试系统

不管你的内核来源, 建立 2.6.x 的模块需要你有一个配置好并建立好的内核树在你的系统中。 这个要求是从之前内核版本的改变, 之前只要有一套当前版本的头文件就足够了。2.6模块针对内核源码树里找到的目标文件连接; 结果是一个更加健壮的模块加载器, 还要求那些目标文件也是可用的。因此你的第一个商业订单是具备一个内核源码树( 或者从krenel.org 网络或者你的发布者的内核源码包), 建立一个新内核, 并且安装到你的系统。

我这里使用的是win10-wsl2-ubuntu22.02

~~~(空)
 uname -a
Linux DESKTOP-WANGS7 6.6.87.2-microsoft-standard-WSL2 #1 SMP PREEMPT_DYNAMIC Thu Jun  5 18:30:46 UTC 2025 x86_64 x86_64 x86_64 GNU/Linux
~~~



## 2.2 Hello World 模块

由于WSL2为微软定制内核本身不支持编译/运行本机内核模块，所以使用交叉编译，使用win10-wsl2-ubuntu22.02为编译主机，VMware-ubuntu18.04为目标主机

~~~(空)
uname -a # 编译主机
Linux DESKTOP-WANGS7 6.6.87.2-microsoft-standard-WSL2 #1 SMP PREEMPT_DYNAMIC Thu Jun  5 18:30:46 UTC 2025 x86_64 x86_64 x86_64 GNU/Linux
~~~

~~~(空)
 uname -a # 目标主机
Linux h3cw32336 5.4.0-150-generic #167~18.04.1-Ubuntu SMP Wed May 24 00:51:42 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux
~~~

编译环境构建：

~~~(空)
# 目标主机

cd /usr/src
sudo tar -czf kernel_headers_5.4.0-150.tar.gz  \
linux-headers-5.4.0-150-generic \
linux-hwe-5.4-headers-5.4.0-150

# 编译主机
mkdir -p kernel_headers/5.4.0-150                                                     
tar -xzf kernel_headers_5.4.0-150.tar.gz -C kernel_headers/5.4.0-150 
~~~

hello_world_kmod：

~~~
.
├── HelloWorld
│   ├── Makefile
│   └── hello_world_kmod.c
├── Makefile
└── README.md
~~~

~~~c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("GG GG");
MODULE_DESCRIPTION("A simple Hello World kernel module");
MODULE_VERSION("0.1");

// 模块初始化函数
static int __init hello_init(void) {
    printk(KERN_INFO "Hello, world! Module loaded.\n");
    return 0;
}

// 模块卸载函数
static void __exit hello_exit(void) {
    printk(KERN_INFO "Goodbye, world! Module unloaded.\n");
}

module_init(hello_init);
module_exit(hello_exit);

~~~

~~~~makefile
# HelloWord/Makefile
# 目标模块名：hello_world_kmod.ko
obj-m := hello_world_kmod.o

# KDIR 指向当前运行内核的头文件目录
KDIR := $(HOME)/Github/kernel_headers/5.4.0-150/linux-headers-5.4.0-150-generic

# 当前模块所在目录
PWD := $(shell pwd)

all:
	$(MAKE) -C $(KDIR) M=$(PWD) modules

clean:
	$(MAKE) -C $(KDIR) M=$(PWD) clean
~~~~

编译后copy到宿主机中：

~~~(空)
# dmesg -w 监视log
# sudo insmod hello_world_kmod.ko 后
[ 3019.379177] Hello, world! Module loaded.
# sudo rmmod hello_world_kmod.ko 后
[ 3032.804443] Goodbye, world! Module unloaded.

# sudo inmod hello_world_kmod.ko后 sudo rmmod hello_world_kmod.ko 前
# 执行 lsmod | grep hello
hello_world_kmod       16384  0
# sudo rmmod hello_world_kmod.ko 后 
无输出
~~~

这个模块定义了两个函数, 一个在模块加载到内核时被调用( hello_init )以及一个在模块被去除时被调用( hello_exit )。 moudle_init 和 module_exit 这几行使用了特别的内核宏来指出这两个函数的角色。另一个特别的宏 MODULE_LICENSE) 是用来告知内核, 该模块带有一个自由的许可证; 没有这样的说明, 在模块加载时内核会抱怨。
printk 函数在 Linux 内核中定义并且对模块可用; 它与标准 C 库函数 printf 的行为相似。内核需要它自己的打印函数, 因为它靠自己运行, 没有 C 库的帮助. 模块能够调用printk 是因为, 在 insmod 加载了它之后, 模块被连接到内核并且可存取内核的公用符号(函数和变量, 下一节详述). 字串 KERN_INFO 是消息的优先级。

每个宏的作用如下：

1. **MODULE_LICENSE**

这个宏用于指定模块的许可证类型。在这里，`"GPL"` 表示该模块遵循 GNU 通用公共许可证（General Public License）。这对于内核模块来说非常重要，因为它会影响模块的加载方式以及是否会导致内核模块被拒绝加载。

- 作用：
  - 明确标明模块遵循的许可证，通常是为了保证代码的开源性。
  - 如果没有指定许可证或者指定为不兼容的许可证（如 `proprietary`），内核会拒绝加载该模块（出于与内核许可证一致性的考虑）。
  - `GPL` 表示模块源代码可以自由使用、修改和分发。

2. **MODULE_AUTHOR**

该宏用于指定模块的作者，可以是个人或组织的名称。它提供了模块的作者信息，便于他人了解模块的开发者。

- 作用：
  - 标识模块的作者，通常是开发该模块的开发者或团队。
  - 这个信息通常会出现在内核日志和一些调试信息中，用于追溯模块的开发者。

3. **MODULE_DESCRIPTION**

该宏用于提供模块的简短描述信息。这个描述应该清晰地说明模块的功能。

- 作用：
  - 给出模块的简要说明，便于其他开发者或者用户了解模块的用途。
  - 在内核日志中，加载或卸载模块时会显示此描述。

4. **MODULE_VERSION**

该宏用于指定模块的版本号。它帮助标识模块的版本，通常在模块的开发过程中非常有用。

- 作用：
  - 提供模块的版本信息，可以帮助开发者区分不同版本的模块。
  - 在调试和维护中，这个版本号可以帮助确定模块的改动历史。
  - 在加载模块时，内核也会显示此版本号，便于进行版本跟踪。



## 2.3 内核模块相比于应用程序

不同于大部分的小的和中型的应用程序从头至尾处理一个单个任务, 每个内核模块只注册自己以便来服务将来的请求, 并且它的初始化函数立刻终止。换句话说, 模块初始化函数的任务是为以后调用模块的函数做准备; 好像是模块说, " 我在这里, 这是我能做的。"模块的退出函数( 例子里是 hello_exit )就在模块被卸载时调用. 它好像告诉内核, "我不再在那里了, 不要要求我做任何事了。"这种编程的方法类似于事件驱动的编程, 但是虽然不是所有的应用程序都是事件驱动的, 每个内核模块都是.。

另外一个主要的不同, 在事件驱动的应用程序和内核代码之间, 是退出函数: 一个终止的应用程序可以在释放资源方面懒惰, 或者完全不做清理工作, ==但是模块的退出函数必须小心恢复每个由初始化函数建立的东西, 否则会保留一些东西直到系统重启。==

卸载模块的能力是你将最欣赏的模块化的其中一个特色, 因为它有助于减少开发时间; 你可测试你的新驱动的连续的版本, 而不用每次经历漫长的关机/重启周期。

一个应用程序可以调用它没有定义的函数:连接阶段使用合适的函数库解决了外部引用。printf 是一个这种可调用的函数并且在 libc 里面定义. 一个模块, 在另一方面, 只连接到内核, 它能够调用的唯一的函数是内核输出的那些; 没有库来连接。在 hello.c 中使用的 printk 函数。例如, 是在内核中定义的 printf 版本并且输出给模块。它表现类似于原始的函数, 只有几个小的不同, **首要的一个是缺乏浮点的支持**。

因为没有库连接到模块中, 源文件不应当包含通常的头文件, <stdarg.h>和非常特殊的情况是仅有的例外。只有实际上是内核的一部分的函数才可以在内核模块里使用。内核相关的任何东西都在头文件里声明, 这些头文件在你已建立和配置的内核源码树里; 大部分相关的头文件位于 include/linux 和 include/asm, 但是别的 include 的子目录已经添加到关联特定内核子系统的材料里了。单个内核头文件的作用在书中需要它们的时候进行介绍。

另外一个在内核编程和应用程序编程之间的重要不同是每一个环境是如何处理错误: 在应用程序开发中段错误是无害的, 一个调试器常常用来追踪错误到源码中的问题, 而一个内核错误至少会杀掉当前进程, 如果不终止整个系统。

### 2.3.1 用户空间和内核空间

**A module runs in kernel space, whereas applications run in user space. This concept is at**
**the base of operating systems theory.**

**一个模块在内核空间运行, 而应用程序在用户空间运行. 这个概念是操作系统理论的基础。**

操作系统的角色, 实际上, 是给程序提供一个一致的计算机硬件的视角。另外, 操作系统必须承担程序的独立操作和保护对于非授权的资源存取。这一不平凡的任务只有 CPU 增强系统软件对应用程序的保护才有可能。

每种现代处理器都能够加强这种行为。 选中的方法是 CPU 自己实现不同的操作形态(或者级别)。 这些级别有不同的角色, 一些操作在低些级别中不允许; 程序代码只能通过有限的几个门从一种级别切换到另一个。Unix 系统设计成利用了这种硬件特性, 使用了两个这样的级别。所有当今的处理器至少有两个保护级别, 并且某些, 例如 x86 家族, 有更多级别;当几个级别存在时, 使用最高和最低级别。 在 Unix 下, 内核在最高级运行( 也称之为超级模式 ), 这里任何事情都允许, 而应用程序在最低级运行(所谓的用户模式), 这里处理器控制了对硬件的直接存取以及对内存的非法存取。

我们常常提到运行模式作为**内核空间**和**用户空间**。这些术语不仅包含存在于这两个模式中不同特权级别, 还包含有这样的事实, 即每个模式有它自己的内存映射 -- 它自己的地址空间。

Unix 从用户空间转换执行到内核空间, 无论何时一个应用程序发出一个系统调用或者被硬件中断挂起时。执行系统调用的内核代码在进程的上下文中工作 -- 它代表调用进程并且可以存取该进程的地址空间。换句话说, 处理中断的代码对进程来说是异步的, 不和任何特别的进程有关。

模块的角色是扩展内核的功能; 模块化的代码在内核空间运行。经常地一个驱动进行之前提到的两种任务: 模块中**一些的函数作为系统调用的一部分执行**, **一些负责中断处理**。



### 2.3.2 内核的并发

内核编程与传统应用程序编程方式很大不同的是并发问题。大部分应用程序, 多线程的应用程序是一个明显的例外, 典型地是顺序运行的, 从头至尾, 不必要担心其他事情会发生而改变它们的环境。内核代码没有运行在这样的简单世界中, 即便最简单的内核模块必须在这样的概念下编写, 很多事情可能马上发生。

内核编程中有几个并发的来源。自然的, Linux 系统运行多个进程, 在同一时间, 不止一个进程能够试图使用你的驱动。大部分设备能够中断处理器; 中断处理异步运行, 并且可能在你的驱动试图做其他事情的同一时间被调用。几个软件抽象( 例如内核定时器, 第 7章介绍 )也异步运行。而且, 当然, Linux 可以在对称多处理器系统( SMP )上运行, 结果是你的驱动可能在多个 CPU 上并发执行。最后, 在 **2.6, 内核代码已经是可抢占的了; 这个变化使得即便是单处理器会有许多与多处理器系统同样的并发问题**。

==结果, Linux 内核代码, 包括驱动代码, 必须是可重入的 -- 它必须能够同时在多个上下文中运行==。数据结构必须小心设计以保持多个执行线程分开, 并且代码必须小心存取共享数据, 避免数据的破坏。编写处理并发和避免竞争情况( 一个不幸的执行顺序导致不希望的行为的情形 )的代码需要仔细考虑并可能是微妙的。**正确的并发管理在编写正确的内核代码时是必须的**; 由于这个理由, 本书的每一个例子驱动都是考虑了并发下编写的。用到的技术在我们遇到它们时再讲解; 第 5 章也专门讲述这个问题, 以及并发管理的可用的内核原语。

驱动程序员的一个通常的错误是假定并发不是一个问题, 只要一段特别的代码没有进入睡眠( 或者 "阻塞" )。即便在之前的内核( 不可抢占), 这种假设在多处理器系统中也不成立。在 2.6, 内核代码不能(极少)假定它能在一段给定代码上持有处理器。如果你不考虑并发来编写你的代码, 就极有可能导致严重失效, 以至于非常难于调试。



### 2.3.3 当前进程

尽管内核模块不象应用程序一样顺序执行, 内核做的大部分动作是代表一个特定进程的。内核代码可以引用当前进程, 通过存取全局项 current, 它在 <asm/current.h> 中定义,它产生一个指针指向结构 task_struct, 在 <linux/sched.h> 定义。current 指针指向当前在运行的进程。在一个系统调用执行期间, 例如 open 或者 read, 当前进程是发出调用的进程。内核代码可以通过使用 current 来使用进程特定的信息, 如果它需要这样。 这种
技术的一个例子在第 6 章展示.

实际上, current 不真正地是一个全局变量。支持 SMP 系统的需要强迫内核开发者去开发一种机制, 在相关的 CPU 上来找到当前进程。 这种机制也必须快速, 因为对 current 的引用非常频繁地发生。 结果就是一个依赖体系的机制, 常常, 隐藏了一个指向task_struct 的指针在内核堆栈内。实现的细节对别的内核子系统保持隐藏, 一个设备驱
动可以只包含 <linux/sched.h> 并且引用当前进程。例如, 下面的语句打印了当前进程的进程 ID 和命令名称, 通过存取结构 task_struct 中的某些字段。

~~~c
printk(KERN_INFO "The process is \"%s\" (pid %i)\n", current->comm, current->pid);
~~~

存于 current->comm 的命令名称是由当前进程执行的程序文件的基本名称( 截短到 15 个字符, 如果需要 )。

简单的实验案例

~~~c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/sched.h>  // 包含 task_struct 和 current

MODULE_LICENSE("GPL");
MODULE_AUTHOR("GG GG");
MODULE_DESCRIPTION("Kernel module to print current process information");
MODULE_VERSION("0.1");

static int __init get_pid_kmod_init(void)
{
    printk(KERN_INFO "The process is \"%s\" (pid %i)\n", current->comm, current->pid);
    return 0;
}

static void __exit get_pid_kmod_exit(void)
{
    printk(KERN_INFO "Goodbye from get_pid_kmod\n");
}

module_init(get_pid_kmod_init);
module_exit(get_pid_kmod_exit);
~~~

~~~(空)
# sudo insmod get_pid_kmod.ko 后
[14696.414913] The process is "insmod" (pid 11983)
# sudo rmmod get_pid_kmod.ko 后
[14720.304069] Goodbye from get_pid_kmod
~~~



### 2.3.4 几个特别的细节

内核编程与用户空间编程在许多方面不同。我们将在本书的过程中指出它们, 但是有几个基础性的问题, 尽管没有保证它们自己有一节内容, 也值得一提。因此, 当你深入内核时,下面的事项应当牢记。

* **节省空间**

应用程序存在于虚拟内存中, 有一个非常大的堆栈区。当然, 堆栈是用来保存函数调用历史以及所有的由当前活跃的函数创建的自动变量。内核, 相反, 有一个非常小的堆栈;它可能小到一个, 4096 字节的页。你的函数必须与这个内核空间调用链共享这个堆栈。因此, 声明一个巨大的自动变量从来就不是一个好主意; 如果你需要大的结构, 你应当在调用时间内动态分配。

* **小心调用“__xxx”双下划线开头的函数**

常常, 当你查看内核 API 时, 你会遇到以双下划线(`__`)开始的函数名。**这样标志的函数名通常是一个低层的接口组件, 应当小心使用。**本质上讲, 双下划线告诉程序员:" 如果你调用这个函数, 确信你知道你在做什么。"

* **内核代码不能使用浮点运算**

内核代码不能做浮点算术。使能浮点将要求内核在每次进出内核空间的时候保存和恢复浮点处理器的状态 -- 至少, 在某些体系上。在这种情况下, 内核代码真的没有必要包含浮点, 额外的负担不值得。



## 2.4 编译和加载

本章开头的 "hello world" 例子包含了一个简短的建立并加载模块到系统中去的演示。当然, 整个过程比我们目前看到的多。本节提供了更多细节关于一个模块作者如何将源码转换成内核中的运行的子系统。

### 2.4.1 编译模块

第一步, 我们需要看一下模块如何必须被建立。模块的建立过程与用户空间的应用程序的建立过程有显著不同; 内核是一个大的, 独立的程序, 对于它的各个部分如何组合在一起有详细的明确的要求。建立过程也与以前版本的内核的过程不同; 新的建立系统用起来更简单并且产生更正确的结果, 但是它看起来与以前非常不同。内核建立系统是一头负责的野兽, 我们就看它一小部分。在内核源码的 Document/kbuild 目录下发现的文件, 任何想理解表面之下的真实情况的人都要阅读一下。

有几个前提, 你必须在能建立内核模块前解决。第一个是保证你有版本足够新的编译器,模块工具, 以及其他必要工具. 在内核文档目录下的文件 Documentation/Changes 一直列出了需要的工具版本; 你应当在向前走之前参考一下它。试图建立一个内核(包括它的模块), 用错误的工具版本, 可能导致不尽的奇怪的难题。**注意, 偶尔地, 编译器的版本太新可能会引起和太老的版本引起的一样的问题。内核源码对于编译器做了很大的假设, 新的发行版本有时会一时地破坏东西。**

如果你仍然没有一个内核树在手边, 或者还没有配置和建立内核, 现在是时间去做了。没有源码树在你的文件系统上, 你无法为 2.6 内核建立可加载的模块。实际运行为其而建立的内核也是有帮助的( 尽管不是必要的 。

一旦你已建立起所有东西, 给你的模块创建一个 makefile 就是直截了当的。实际上, 对于本章前面展示的" hello world" 例子, 单行就够了:

~~~makefile
obj-m := hello_world_kmod.o
~~~

熟悉 make , 但是对 2.6 内核建立系统不熟悉的读者, 可能奇怪这个 makefile 如何工作。毕竟上面的这一行不是一个传统的 makefile 的样子。答案, 当然, 是内核建立系统处理了余下的工作。（或者像我的案例一样自己配置其他参数和动作）上面的安排( 它利用了由 GNU make 提供的扩展语法 )表明有一个模块要从目标文件 hello_world_kmod.o 建立. 在从目标文件建立后结果模块命名为 hello_world_kmod.ko。

反之, 如果你有一个模块名为 module.ko, 是来自 2 个源文件( 姑且称之为, file1.c 和 file2.c ), 正确的书写应当是:

~~~makefile
obj-m := module.o
module-objs := file1.o file2.o
~~~

对于一个象上面展示的要工作的 makefile, 它必须在更大的内核建立系统的上下文被调用。如果你的内核源码数位于, 假设, 你的 ~/kernel-2.6 目录, 用来建立你的模块的 make命令( 在包含模块源码和 makefile 的目录下键入 )会是:

~~~makefile
make -C ~/kernel-2.6 M=`pwd` modules
# 类似的在我使用的wsl2环境中需要使用：
# $(MAKE) -C $(KDIR) M=$(PWD) modules
~~~

这个命令开始是改变它的目录到用 -C 选项提供的目录下( 就是说, 你的内核源码目录 )。它在那里会发现内核的顶层 makefile。 这个 M= 选项使 makefile 在试图建立模块目标前,回到你的模块源码目录。这个目标, 依次地, 是指在 obj-m 变量中发现的模块列表, 在我们的例子里设成了 module.o。



### 2.4.2 加载和卸载模块

模块建立之后, 下一步是加载到内核。如我们已指出的, insmod 为你完成这个工作. 这个程序加载模块的代码段和数据段到内核, 接着, 执行一个类似 ld 的函数, 它连接模块中任何未解决的符号连接到内核的符号表上。但是不象连接器, 内核不修改模块的磁盘文件,而是内存内的拷贝。insmod 接收许多命令行选项(详情见 manpage), 它能够安排值给你模块中的参数, 在连接到当前内核之前。因此, 如果一个模块正确设计了, 它能够在加载时配置; 加载时配置比编译时配置给了用户更多的灵活性, 有时仍然在用. 加载时配置在本章后面的 "模块参数" 一节讲解。

感兴趣的读者可能想看看内核如何支持 insmod: 它依赖一个在 kernel/module.c 中定义的系统调用。函数 sys_init_module 分配内核内存来存放模块 ( 这个内存用 vmalloc 分配; 看第 8 章的 "vmalloc 和其友" ); 它接着拷贝模块的代码段到这块内存区, 借助内核符号表解决模块中的内核引用, 并且调用模块的初始化函数来启动所有东西。

如果你真正看了内核代码, 你会发现系统调用的名子以 sys_ 为前缀。这对所有系统调用都是成立的, 并且没有别的函数。记住这个有助于在源码中查找系统调用。

**modprobe** 工具值得快速提及一下。modprobe, 如同 insmod, 加载一个模块到内核。它的不同在于它会查看要加载的模块, 看是否它引用了当前内核没有定义的符号。如果发现有,modprobe 在定义相关符号的当前模块搜索路径中寻找其他模块. 当 modprobe 找到这些模块( 要加载模块需要的 ), 它也把它们加载到内核。如果你在这种情况下代替以使用insmod , 命令会失败, 在系统日志文件中留下一条 " unresolved symbols "消息。

如前面提到, 模块可以用 rmmod 工具从内核去除。注意, 如果内核认为模块还在用( 就是说, 一个程序仍然有一个打开文件对应模块输出的设备 ), 或者内核被配置成不允许模块去除, 模块去除会失败。可以配置内核允许"强行"去除模块, 甚至在它们看来是忙的。如果你到了需要这选项的地步, 但是, 事情可能已经错的太严重以至于最好的动作就是重启了。

lsmod 程序生成一个内核中当前加载的模块的列表。一些其他信息, 例如使用了一个特定模块的其他模块, 也提供了。lsmod 通过读取 /proc/modules 虚拟文件工作。当前加载的模块的信息也可在位于 /sys/module 的 sysfs 虚拟文件系统找到。



### 2.4.3 版本依赖

记住, **你的模块代码一定要为每个它要连接的内核版本重新编译** -- 至少, 在缺乏modversions 时, 这里不涉及因为它们更多的是给内核发布制作者, 而不是开发者。模块是紧密结合到一个特殊内核版本的数据结构和函数原型上的; 模块见到的接口可能一个内核版本与另一个有很大差别。当然, 在开发中的内核更加是这样。

内核不只是认为一个给定模块是针对一个正确的内核版本建立的。建立过程的其中一步是对一个当前内核树中的文件(称为 vermagic.o)连接你的模块; 这个东东含有相当多的有关要为其建立模块的内核的信息, 包括目标内核版本, 编译器版本, 以及许多重要配置变量的设置。当尝试加载一个模块, 这些信息被检查与运行内核的兼容性。如果不匹配, 模块不会加载; 代之的是你见到如下内容:

~~~(空)
# insmod hello.ko
Error inserting './hello.ko': -1 Invalid module format
~~~

看一下系统日志文件(/var/log/message 或者任何你的系统被配置来用的)将发现导致模块无法加载特定的问题。

如果你需要编译一个模块给一个特定的内核版本, 你将需要使用这个特定版本的建立系统和源码树. 前面展示过的在例子 makefile 中简单修改 KERNELDIR 变量, 就完成这个动作。

内核接口在各个发行之间常常变化。 如果你编写一个模块想用来在多个内核版本上工作(特别地是如果它必须跨大的发行版本), 你可能只能使用宏定义和 `#ifdef` 来使你的代码正确建立。本书的这个版本只关心内核的一个主要版本, 因此不会在我们的例子代码中经常见到版本检查。但是这种需要确实有时会有。在这样情况下, 你要利用在 linux/version.h中发现的定义。这个头文件, 自动包含在 linux/module.h, 定义了下面的宏定义:

~~~c
UTS_RELEASE //这个宏定义我在我的环境中对应的头文件中暂未找到
~~~

这个宏定义扩展成字符串, 描述了这个内核树的版本. 例如, "2.6.10".

~~~c
LINUX_VERSION_CODE //这个找到了
// 我的编译环境中对应的定义如下：
#define LINUX_VERSION_CODE 328937
// KERNEL_VERSION(5, 4, 0) = (5 << 16) | (4 << 8) | 0
//327680 | 1024 | 0 = 328704 对不上 很奇怪暂不研究
~~~

~~~
 grep -nr "LINUX_VERSION_CODE" 
linux-headers-5.4.0-84-generic/include/generated/uapi/linux/version.h:1:
#define LINUX_VERSION_CODE 328837

linux-headers-5.4.0-150-generic/include/generated/uapi/linux/version.h:1:
#define LINUX_VERSION_CODE 328937

~~~

KERNEL_VERSION(major,minor,release)这个宏定义用来建立一个整型版本编码, 从组成一个版本号的单个数字。 例如,KERNEL_VERSION(2.6.10) 扩展成 132618。 这个宏定义非常有用, 当你需要比较当前版本和一个已知的检查点。

~~~c
#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + ((c) > 255 ? 255 : (c)))
~~~

大部分的基于内核版本的依赖性可以使用预处理器条件解决, 通过利用 `KERNEL_VERSION`和`LINUX_VERSION_VODE`。版本依赖不应当, 但是, 用繁多的 `#ifdef` 条件来搞乱驱动的代码; 处理不兼容的最好的方式是把它们限制到特定的头文件。作为一个通用的原则, 明显版本(或者平台)依赖的代码应当隐藏在一个低级的宏定义或者函数后面。高层的代码就可以只调用这些函数, 而不必关心低层的细节. 这样书写的代码易读并且更健壮。



### 2.4.4 平台依赖性

如果一个模块与一个给定内核工作, 它必须以与内核相同的对目标处理器的理解来建立。再一次, vermagic.o 目标文件登场。当加载一个模块, 内核为模块检查特定处理器的配置选项, 确认它们匹配运行的内核。如果模块用不同选项编译, 它不会加载。

如果你计划为通用的发布编写驱动, 你可能很奇怪你怎么可能支持所有这些不同的变体。最好的答案, 当然, 是发行你的驱动在 GPL 兼容的许可之下, 并且贡献它给主流内核。如果没有那样, 以源码形式和一套脚本发布你的驱动, 以便在用户系统上编译可能是最好的答案。一些供应商已发行了工具来简化这个工作。如果你必须发布你的驱动以二进制形式,你需要查看由你的目标发布所提供的不同的内核, 并且为每个提供一个模块版本。要确认考虑到了任何在产生发布后可能发行的勘误内核。接着, 要考虑许可权的问题, 如同我们在第 1 章的" 许可条款" 一节中讨论的.。作为一个通用的规则, 以源码形式发布东西是你行于世的易途。



## 2.5 内核符号表

我们已经看到 insmod 如何对应共用的内核符号来解决未定义的符号。表中包含了全局内核项的地址 -- 函数和变量 -- 需要来完成模块化的驱动。当加载一个模块, 如何由模块输出的符号成为内核符号表的一部分。通常情况下, 一个模块完成它自己的功能不需要输出如何符号。你需要输出符号, 但是, 在任何别的模块能得益于使用它们的时候。

新的模块可以用你的模块输出的符号, 你可以堆叠新的模块在其他模块之上。模块堆叠在主流内核源码中也实现了: msdos 文件系统依赖 fat 模块输出的符号, 某一个输入 USB设备模块堆叠在 usbcore 和输入模块之上。

模块堆叠在复杂的工程中有用处。如果一个新的抽象以驱动程序的形式实现, 它可能提供一个特定硬件实现的插入点。例如, video-for-linux 系列驱动分成一个通用模块, 输出了由特定硬件的低层设备驱动使用的符号。根据你的设置, 你加载通用的视频模块和你的已安装硬件对应的特定模块。

当使用堆叠的模块时, 熟悉 modprobe 工具是有帮助的。如我们前面讲的, modprobe 函数很多地方与 insmod 相同, 但是它也加载任何你要加载的模块需要的其他模块。所以, 一个 modprobe 命令有时可能代替几次使用 nsmod( 尽管你从当前目录下加载你自己模块仍将需要 insmod, 因为 modprobe 只查找标准的已安装模块目录 )。

linux 内核头文件提供了方便来管理你的符号的可见性, 因此减少了命名空间的污染( 将与在内核别处已定义的符号冲突的名子填入命名空间), 并促使了正确的信息隐藏。如果你的模块需要输出符号给其他模块使用, 应当使用下面的宏定义:

~~~c
EXPORT_SYMBOL(name);
EXPORT_SYMBOL_GPL(name);
~~~

上面宏定义的任一个使得给定的符号在模块外可用。_GPL 版本的宏定义只能使符号对 GPL许可的模块可用。符号必须在模块文件的全局部分输出, 在任何函数之外, 因为宏定义扩展成一个特殊用途的并被期望是全局存取的变量的声明。这个变量存储于模块的一个特殊的可执行部分( 一个 "ELF 段" ), 内核用这个部分在加载时找到模块输出的变量。( 感兴趣的读者可以看 <linux/module.h> 获知详情, 尽管并不需要这些细节使东西动起来。 )



## 2.6 预备知识

我们正在接近去看一些实际的模块代码.。但是首先, 我们需要看一些需要出现在你的模块源码文件中的东西。内核是一个独特的环境, 它将它的要求强加于要和它接口的代码上。大部分内核代码包含了许多数量的头文件来获得函数, 数据结构和变量的定义。我们将在碰到它们时检查这些文件, 但是有几个文件对模块是特殊的, 必须出现在每一个可加载模块中。因此, 几乎所有模块代码都有下面内容:

~~~c
#include <linux/module.h>
#include <linux/init.h>
~~~

> * moudle.h 包含了大量加载模块需要的函数和符号的定义。
> * 你需要 init.h 来指定你的初始化和清理函数, 如我们在上面的 "hello world" 例子里见到的。
> * 大部分模块还包含 moudleparam.h, 使得可以在模块加载时传递参数给模块。

不是严格要求的, 但是你的模块确实应当指定它的代码使用哪个许可. 做到这一点只需包含一行 MODULE_LICENSE:

~~~c
MODULE_LICENSE("GPL");
~~~

> 内核认识的特定许可有, "GPL"( 适用 GNU 通用公共许可的任何版本 ), "GPL v2"( 只适用 GPL 版本 2 ), "GPL and additional rights", "Dual BSD/GPL", "Dual MPL/GPL",和 "Proprietary"。除非你的模块明确标识是在内核认识的一个自由许可下, 否则就假定它是私有的, 内核在模块加载时被"弄污浊"了。

可以在模块中包含的其他描述性定义有 `MODULE_AUTHOR` ( 声明谁编写了模块 ),`MODULE_DESCRIPION`( 一个人可读的关于模块做什么的声明 ), `MODULE_VERSION` ( 一个代码修订版本号; 看 <linux/module.h> 的注释以便知道创建版本字串使用的惯例),`MODULE_ALIAS` ( 模块为人所知的另一个名子 ), 以及 `MODULE_DEVICE_TABLE` ( 来告知用户空间, 模块支持那些设备 ). 我们会讨论 `MODULE_ALIAS` 在第 11 章以及`MUDULE_DEVICE_TABLE` 在第 12 章.

各种 `MODULE_ `声明可以出现在你的源码文件的任何函数之外的地方. 但是, 一个内核代码中相对近期的惯例是把这些声明放在文件末尾.



## 2.7 初始化和关停

### 2.7.1 初始化函数

如已提到的, 模块初始化函数注册模块提供的任何功能. 这些功能, 我们指的是新功能,可以由应用程序存取的或者一整个驱动或者一个新软件抽象。实际的初始化函数定义常常如:

~~~c
static int __init initialization_function(void)
{
	/* Initialization code here */
}
module_init(initialization_function);
~~~

初始化函数应当声明成静态的, 因为它们不会在特定文件之外可见; 没有硬性规定这个,然而, 因为没有函数能输出给内核其他部分, 除非明确请求。

> 声明中的` __init` 标志可能看起来有点怪; 它是一个给内核的暗示, 给定的函数只是在初始化使用。模块加载者在模块加载后会丢掉这个初始化函数, 使它的内存可做其他用途。

> 一个类似的标签(`__initdata`) 给只在初始化时用的数据. 使用 `__init` 和 `__initdata` 是可选的, 但是它带来的麻烦是值得的。只是要确认不要用在那些在初始化完成后还使用的函数(或者数据结构)上。

> 你可能还会遇到 `__devinit `和 _`_devinitdata` 在内核源码里; 这些只在内核没有配置支持 hotplug 设备时转换成 `__init` 和 `_initdata`。

==使用 moudle_init 是强制的. 这个宏定义增加了特别的段到模块目标代码中, 表明在哪里找到模块的初始化函数. 没有这个定义, 你的初始化函数不会被调用。==

模块可以注册许多的不同设施, 包括不同类型的设备, 文件系统, 加密转换, 以及更多。对每一个设施, 有一个特定的内核函数来完成这个注册。传给内核注册函数的参数常常是一些数据结构的指针, 描述新设施以及要注册的新设施的名子。数据结构常常包含模块函数指针, 模块中的函数就是这样被调用的。

能够注册的项目远远超出第 1 章中提到的设备类型列表。它们包括, 其他的, 串口, 多样设备, sysfs 入口, /proc 文件, 执行域, 链路规程。这些可注册项的大部分都支持不直接和硬件相关的函数, 但是处于"软件抽象"区域里。这些项可以注册, 是因为它们以各种方式(例如象 /proc 文件和链路规程)集成在驱动的功能中。

对某些驱动有其他的设施可以注册作为补充, 但它们的使用太特别, 所以不值得讨论它们。它们使用堆叠技术, 在"内核符号表"一节中讲过。如果你想深入探求, 你可以在内核源码里查找 `EXPORT_SYMBOL `, 找到由不同驱动提供的入口点。大部分注册函数以 `register_`做前缀, 因此找到它们的另外一个方法是在内核源码里查找 `register_` 。



### 2.7.2 清理函数

每个非试验性的模块也要求有一个清理函数, 它注销接口, 在模块被去除之前返回所有资源给系统. 这个函数定义为:

~~~c
static void __exit cleanup_function(void)
{
	/* Cleanup code here */
}
module_exit(cleanup_function);
~~~

清理函数没有返回值, 因此它被声明为 void。` __exit` 修饰符标识这个代码是只用于模块卸载( 通过使编译器把它放在特殊的 ELF 段)。如果你的模块直接建立在内核里, 或者如果你的内核配置成不允许模块卸载, 标识为 `__exit` 的函数被简单地丢弃。因为这个原因,一个标识 `__exit` 的函数只在模块卸载或者系统停止时调用; 任何别的使用是错的。再一次, `moudle_exit` 声明对于使得内核能够找到你的清理函数是必要的。

如果你的模块没有定义一个清理函数, 内核不会允许它被卸载。



### 2.7.3 初始化中的错误处理

你必须记住一件事, 在注册内核设施时, 注册可能失败。即便最简单的动作常常需要内存分配, 分配的内存可能不可用。**因此模块代码必须一直检查返回值, 并且确认要求的操作实际上已经成功**。

> 如果在你注册工具时发生任何错误, 首先第一的事情是决定模块是否能够无论如何继续初始化它自己。常常, 在一个注册失败后模块可以继续操作, **如果需要可以功能降级**。在任何可能的时候, 你的模块应当尽力向前, 并提供事情失败后具备的能力。

> 如果证实你的模块在一个特别类型的失败后完全不能加载, 你必须取消任何在失败前注册的动作。内核不保留已经注册的设施的每模块注册, 因此如果初始化在某个点失败, **模块必须能自己退回所有东西**。如果你无法注销你获取的东西, 内核就被置于一个不稳定状态;它包含了不存在的代码的内部指针。这种情况下, 经常地, 唯一的方法就是重启系统。在初始化错误发生时, 你确实要小心地将事情做正确。

错误恢复有时用 goto 语句处理是最好的。我们通常不愿使用 goto, 但是在我们的观念里,这是一个它有用的地方。在错误情形下小心使用 goto 可以去掉大量的复杂, 过度对齐的,"结构形" 的逻辑。因此, 在内核里, goto 是处理错误经常用到, 如这里显示的。

下面例子代码( 使用设施注册和注销函数)在初始化在任何点失败时做得正确:

~~~c
int __init my_init_function(void)
{
    int err;
    err = register_this(ptr1, "skull"); /* registration takes a pointer and a name */
    if (err)
    	goto fail_this;
    err = register_that(ptr2, "skull");
    if (err)
    	goto fail_that;
    err = register_those(ptr3, "skull");
    if (err)
    	goto fail_those;
    return 0; /* success */
fail_those:
    unregister_that(ptr2, "skull");
fail_that:
    unregister_this(ptr1, "skull");
fail_this:
    return err; /* propagate the error */
}
~~~

这段代码试图注册 3 个(虚构的)设施。goto 语句在失败情况下使用, 在事情变坏之前只对之前已经成功注册的设施进行注销。

另一个选项, 不需要繁多的 goto 语句, 是跟踪已经成功注册的, 并且在任何出错情况下调用你的模块的清理函数。清理函数只回卷那些已经成功完成的步骤。然而这种选择, 需要更多代码和更多 CPU 时间, 因此在快速途径下, 你仍然依赖于 goto 作为最好的错误恢复工具。

`my_init_function` 的返回值, err, 是一个错误码. 在 Linux 内核里, 错误码是负数, 属于定义于 <linux/errno.h> 的集合。如果你需要产生你自己的错误码代替你从其他函数得到的返回值, 你应当包含 <linux/errno.h> 以便使用符号式的返回值, 例如 `-ENODEV`, `-ENOMEM`, 等等。返回适当的错误码总是一个好做法, 因为用户程序能够把它们转变为有意义的字串, 使用 `perror` 或者类似的方法。

显然, 模块清理函数必须撤销任何由初始化函数进行的注册, 并且惯例(但常常不是要求的)是按照注册时相反的顺序注销设施。

~~~c
void __exit my_cleanup_function(void)
{
    unregister_those(ptr3, "skull");
    unregister_that(ptr2, "skull");
    unregister_this(ptr1, "skull");
    return;
}
~~~

如果你的初始化和清理比处理几项复杂, goto 方法可能变得难于管理, 因为所有的清理代码必须在初始化函数里重复, 包括几个混合的标号。有时, 因此, 一种不同的代码排布证明更成功。

使代码重复最小和所有东西流线化, 你应当做的是无论何时发生错误都从初始化里调用清理函数。清理函数接着必须在撤销它的注册前检查每一项的状态。以最简单的形式, 代码看起来象这样:

~~~c
struct something *item1;
struct somethingelse *item2;
int stuff_ok;

void my_cleanup(void)
{
    if (item1)
    	release_thing(item1);
    if (item2)
    	release_thing2(item2);
    if (stuff_ok)
    	unregister_stuff();
    return;
}

int __init my_init(void)
{
    int err = -ENOMEM;
    item1 = allocate_thing(arguments);
    item2 = allocate_thing2(arguments2);
    if (!item2 || !item2)
    	goto fail;
    err = register_stuff(item1, item2);
    if (!err)
    	stuff_ok = 1;
    else
    	goto fail;
    return 0; /* success */
fail:
    my_cleanup();
    return err;
}
~~~

如这段代码所示, 你也许需要, 也许不要外部的标志来标识初始化步骤的成功, 要依赖你调用的注册/分配函数的语义。不管要不要标志, 这种初始化会变得包含大量的项, 常常比之前展示的技术要好。**注意, 清理函数当由非退出代码调用时不能标志为 __exit,如同前面的例子**。



### 2.7.4 模块加载竞争

到目前, 我们的讨论已来到一个模块加载的重要方面: 竞争情况。如果你在如何编写你的初始化函数上不小心, 你可能造成威胁到整个系统的稳定的情形。我们将在本书稍后讨论竞争情况; 现在, 快速提几点就足够了:

首先时你应该一直记住, 内核的某些别的部分会在注册完成之后马上使用任何你注册的设施。这是完全可能的, 换句话说, 内核将调用进你的模块, 在你的初始化函数仍然在运行时。所以你的代码一旦它完成了它的第一个注册就必须准备好被调用。直到所有的需要支持那个设施的你的内部初始化已经完成其不要注册任何设施。

你也必须考虑到如果你的初始化函数决定失败会发生什么, 但是内核的一部分已经在使用你的模块已注册的设施。如果这种情况对你的模块是可能的, 你应当认真考虑根本不要使初始化失败。毕竟, 模块已清楚地成功输出一些有用的东西。如果初始化必须失败, 必须小心地处理任何可能的在内核别处发生的操作, 直到这些操作已完成。



## 2.8 模块参数

驱动需要知道的几个参数因不同的系统而不同。从使用的设备号( 如我们在下一章见到的 )到驱动应当任何操作的几个方面。例如, SCSI 适配器的驱动常常有选项控制标记命令队列的使用, IDE 驱动允许用户控制 DMA 操作。如果你的驱动控制老的硬件, 还需要被明确告知哪里去找硬件的 I/O 端口或者 I/O 内存地址。内核通过在加载驱动的模块时指定可变参数的值, 支持这些要求。

这些参数的值可由 `insmod` 或者 `modprobe`在加载时指定; 后者也可以从它的配置文件(/etc/modprobe.conf)读取参数的值。这些命令在命令行里接受几类规格的值。作为演示这种能力的一种方法, 想象一个特别需要的对本章开始的"hello world"模块(称为 hellop)的改进。我们增加 2 个参数: 一个整型值, 称为 howmany, 一个字符串称为 whom。我们的特别多功能的模块就在加载时, 欢迎 whom 不止一次, 而是 howmany 次。这样一个模块可以用这样的命令行加载:

~~~(空)
insmod hellop howmany=10 whom="Mom"
~~~

> 一旦以那样的方式加载, hellop 会说 "hello, Mom" 10 次。

但是, 在 `insmod` 可以修改模块参数前, 模块必须使它们可用。参数用 `moudle_param` 宏定义来声明, 它定义在 moduleparam.h。`module_param` 使用了 3 个参数: **变量名**, 它的**类型**, 以及**一个权限掩码**用来做一个辅助的sysfs 入口。这个宏定义应当放在任何函数之外, 典型地是出现在源文件的前面。因此 hellop 将声明它的参数, 并如下使得对 `insmod`可用:

~~~c
static char *whom = "world";
static int howmany = 1;
module_param(howmany, int, S_IRUGO);
module_param(whom, charp, S_IRUGO);
~~~

> 模块参数支持许多类型:
>
> * bool / invbool ：一个布尔型( true 或者 false)值(相关的变量应当是 int 类型)。invbool 类型颠
>   倒了值, 所以真值变成 false, 反之亦然。
> * charp ：一个字符指针值。内存为用户提供的字串分配, 指针因此设置。
> * int / long / short / uint / ulong / ushort：基本的变长整型值。 以 u 开头的是无符号值。

数组参数, 用逗号间隔的列表提供的值, 模块加载者也支持. 声明一个数组参数, 使用:

~~~c
module_param_array(name,type,num,perm);
~~~

这里 `name` 是你的数组的名子(也是参数名), `type` 是数组元素的类型, `num` 是一个整型变量, `perm` 是通常的权限值。如果数组参数在加载时设置, `num` 被设置成提供的数的个数。模块加载者拒绝比数组能放下的多的值。

如果你确实需要一个没有出现在上面列表中的类型, 在模块代码里有钩子会允许你来定义它们; 任何使用它们的细节见 moduleparam.h。所有的模块参数应当给定一个缺省值;`insmod` 只在用户明确告知它的时候才改变这些值。模块可检查明显的参数, 通过对应它们的缺省值检查这些参数。

最后的 `module_param` 字段是一个权限值; 你应当使用 <linux/stat.h> 中定义的值。这个值控制谁可以存取这些模块参数在 `sysfs` 中的表示。如果 `perm` 被设为 0, 就根本没有`sysfs `项。否则, 它出现在 `/sys/module`下面, 带有给定的权限。使用 `S_IRUGO` 作为参数可以被所有人读取, 但是不能改变; `S_IRUGO|S_IWUSR` 允许 root 来改变参数。注意,如果一个参数被 `sysfs` 修改, **你的模块看到的参数值也改变了, 但是你的模块没有任何其他的通知。你应当不要使模块参数可写, 除非你准备好检测这个改变并且因而作出反应。**



## 2.9 在用户空间做

在本节, 我们讨论几个理由, 为什么你可能在用户空间编写驱动.本书是关于内核空间驱动的。但是, 所以我们不超越这个介绍性的讨论。
用户空间驱动的好处在于:

* 完整的 C 库可以连接. 驱动可以进行许多奇怪的任务, 不用依靠外面的程序(实现
  使用策略的工具程序, 常常随着驱动自身发布)。
* 程序员可以在驱动代码上运行常用的调试器, 而不必走调试一个运行中的内核的弯
  路。
* 如果一个用户空间驱动挂起了, 你可简单地杀掉它。驱动的问题不可能挂起整个系
  统, 除非被控制的硬件真的疯掉了。
* 用户内存是可交换的, 不象内核内存. 一个不常使用的却有很大一个驱动的设备不
  会占据别的程序可以用到的 RAM, 除了在它实际在用时。
* 一个精心设计的驱动程序仍然可以, 如同内核空间驱动, 允许对设备的并行存取。
* 如果你必须编写一个封闭源码的驱动, 用户空间的选项使你容易避免不明朗的许可
  的情况和改变的内核接口带来的问题。

例如, USB 驱动能够在用户空间编写; 看libusb 项目, 在libusb.sourceforge.net 和 "gadgetfs" 在内核源码里。另一个例子是 X 服务器: 它确切地知道它能处理哪些硬件, 哪些不能, 并且它提供图形资源给所有的 X 客户。注意, 然而, 有一个缓慢但是固定的漂移向着基于 frame-buffer 的图形环境, X 服务器只是作为一个服务器。有基于一个内核空间的真实的设备驱动, 这个驱动负责真正的图形操作。

常常, 用户空间驱动的编写者完成一个服务器进程, 从内核接管作为单个代理的负责硬件控制的任务。客户应用程序就可以连接到服务器来进行实际的操作; 因此, 一个聪明的驱动经常可以允许对设备的并行存取。这就是 X 服务器如何工作的。

但是用户空间的设备驱动的方法有几个缺点。最重要的是:

* 中断在用户空间无法用。在某些平台上有对这个限制的解决方法, 例如在 IA32 体系上的 vm86 系统调用。
* 只可能通过内存映射 /dev/mem 来使用 DMA, 而且只有特权用户可以这样做。存取 I/O 端口只能在调用ioperm 或者 iopl 之后。此外, 不是所有的平台支持这些系统调用, 而存取/dev/port 可能太慢而无效率。这些系统调用和设备文件都要求特权用户。
* 响应时间慢, 因为需要上下文切换在客户和硬件之间传递信息或动作。
* 更不好的是, 如果驱动已被交换到硬盘, 响应时间会长到不可接受。使用 mlock 系统调用可能会有帮助, 但是常常的你将需要锁住许多内存页, 因为一个用户空间程序依赖大量的库代码. mlock, 也, 限制在授权用户上。
* 最重要的设备不能在用户空间处理, 包括但不限于, 网络接口和块设备。

一种在用户空间工作的情况可能是有意义的, 当你开始处理新的没有用过的硬件时。这样你可以学习去管理你的硬件, 不必担心挂起整个系统. 一旦你完成了, 在一个内核模块中封装软件就会是一个简单操作了。



## 2.10 快速参考

本节总结了我们在本章接触到的内核函数, 变量, 宏定义, 和 /proc 文件。它的用意是作为一个参考。每一项列都在相关头文件的后面, 如果有。从这里开始, 在几乎每章的结尾会有类似一节, 总结一章中介绍的新符号。本节中的项通常以在本章中出现的顺序排列:

~~~shell
insmod
modprobe
rmmod
~~~

用户空间工具, 加载模块到运行中的内核以及去除它们。

---------

~~~c
#include <linux/init.h>
module_init(init_function);
module_exit(cleanup_function);
~~~

指定模块的初始化和清理函数的宏定义。

-------

~~~c
__init
__initdata
__exit
__exitdata
~~~

函数( `__init` 和` __exit` )和数据 (`__initdata` 和 `__exitdata`)的标记, 只用在模块初始化或者清理时间. 为初始化所标识的项可能会在初始化完成后丢弃; 退出的项可能被丢弃如果内核没有配置模块卸载。这些标记通过使相关的目标在可执行文件的特定的 ELF 节里被替换来工作。

-------------------

~~~c
#include <linux/sched.h>
~~~

最重要的头文件中的一个。这个文件包含很多驱动使用的内核 API 的定义, 包括睡眠函数和许多变量声明。

-----------

~~~c
struct task_struct *current; //当前进程。
/* 进程 ID 和 当前进程的命令名. */
current->pid
current->comm
~~~

-----------

~~~shell
obj-m
~~~

一个 makefile 符号, 内核建立系统用来决定当前目录下的哪个模块应当被建立。

---------------------

~~~(空)
/sys/module
/proc/modules
~~~

`/sys/module` 是一个 sysfs 目录层次, 包含当前加载模块的信息。 `/proc/moudles`是旧式的, 那种信息的单个文件版本。其中的条目包含了模块名, 每个模块占用的内存数量, 以及使用计数。另外的字串追加到每行的末尾来指定标志, 对这个模块当前是活动的。

-----------

~~~(空)
vermagic.o 
~~~

来自内核源码目录的目标文件, 描述一个模块为之建立的环境。

---------------------

~~~c
#include <linux/module.h> //必需的头文件. 它必须在一个模块源码中包含.
#include <linux/version.h> //头文件, 包含在建立的内核版本信息.
LINUX_VERSION_CODE //整型宏定义, 对 #ifdef 版本依赖有用.

EXPORT_SYMBOL (symbol);
EXPORT_SYMBOL_GPL (symbol);
//宏定义, 用来输出一个符号给内核. 第 2 种形式输出没有版本信息, 第 3 种限制输出给 GPL 许可的模块。

MODULE_AUTHOR(author);
MODULE_DESCRIPTION(description);
MODULE_VERSION(version_string);
MODULE_DEVICE_TABLE(table_info);
MODULE_ALIAS(alternate_name);
// 放置文档在目标文件的模块中。

module_init(init_function);
module_exit(exit_function);
// 宏定义, 声明一个模块的初始化和清理函数。

#include <linux/moduleparam.h>
module_param(variable, type, perm);
// 宏定义, 创建模块参数, 可以被用户在模块加载时调整( 或者在启动时间, 对于内嵌代码)。
// 类型可以是 bool, charp, int, invbool, short, ushort, uint, ulong,或者 intarray。

#include <linux/kernel.h>
int printk(const char * fmt, ...);
// 内核代码的 printf 类似物。
~~~











