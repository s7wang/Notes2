# 第一部分 简介和TCP/IP

# 第二章 传输层：TCP、UDP 和 SCTP

## 2.1 概述

本章的焦点试试传输层，包括TCP、UDP和SCTP。绝大多数网络应用使用的都是TCP和UDP。

### UDP（User Datagram Protocol）

**📌 概念**

UDP 是**面向无连接**、**不可靠**、**尽力而为（Best-Effort）**的传输层协议。
 特点：无连接、无确认、无重传、无流控、无拥塞控制 → **极快**。

**📌 常见使用场景**

- 实时性要求高：
  - **音视频流媒体（VoIP, WebRTC）**
  - **在线游戏**
  - **直播、视频会议**
- 广播、多播
- 简单查询型协议（DNS、SNMP）

**📌 优点**

- 速度快、延迟低
- 多播和广播支持好
- 协议简单、开销小（头部只有8字节）

**📌 缺点**

- **不保证可靠性**（可能丢包、乱序）
- **不保证顺序**
- **无重传机制**（应用层必须自己处理可靠性）

------

###  TCP（Transmission Control Protocol）

**📌 概念**

TCP 是**面向连接**的、**可靠**的**字节流**协议。
 提供：可靠传输、顺序传输、流控、拥塞控制。

**📌 常见使用场景**

- 需要可靠交付的应用
  - **HTTP/HTTPS（网页）**
  - **FTP 文件传输**
  - **SSH**
  - **SMTP 邮件传输**

**📌 优点**

- **可靠性保证**（确认、重传）
- **顺序保证**
- **流控+拥塞控制**
- 面向字节流，应用编程简单

**📌 缺点**

- 连接建立（三次握手）和释放（四次挥手）带来开销
- 遇丢包重传 → **延迟大**
- 有拥塞控制 → 吞吐会被限制
- 不适合实时应用（语音视频）

------

### SCTP（Stream Control Transmission Protocol）

**📌 概念**

SCTP 是为电信网络设计的传输层协议，结合了 **TCP 的可靠性** 和 **UDP 的多流特性**。
 特点：

- **多流（multi-stream）**：多个独立流，互不影响
- **多宿主（multi-homing）**：多网口多IP，具有路径冗余
- 面向消息（message-oriented）
- 支持可靠传输（类似 TCP）

**📌 常见使用场景**

- 电信信令（SIGTRAN）
- 高可用服务器间通信
- 需要“消息 + 多流 + 冗余”的系统

现代 Linux（内核 3.x+）默认支持 SCTP（需加载模块）。

**📌 优点**

- **可靠传输**（像 TCP）
- **面向消息**（像 UDP）
- **多流**：避免 TCP 的队头阻塞（Head-of-Line Blocking）
- **多宿主**：链路故障自动切换（高可用）

**📌 缺点**

- 普及度低，NAT/防火墙兼容性差
- 编程使用比 TCP/UDP 复杂
- 没有 TCP 那样成熟的生态和优化

| 协议     | 类型            | 可靠性   | 顺序保证     | 多流 | 多宿主 | 延迟   | 典型用途                 |
| -------- | --------------- | -------- | ------------ | ---- | ------ | ------ | ------------------------ |
| **UDP**  | 无连接          | ❌ 不可靠 | ❌            | ❌    | ❌      | ⭐ 最低 | 游戏、直播、VoIP         |
| **TCP**  | 面向连接        | ✔        | ✔            | ❌    | ❌      | 中     | Web、文件传输、SSH       |
| **SCTP** | 面向消息 + 可靠 | ✔        | 可以多流独立 | ✔    | ✔      | 中     | 电信信令、HA、服务间通信 |

一般应用层向下交互使用的API多为套接字或XTI，访问BPF或DLPI的接口不使用套接字或XTI。（一种例外：LInux使用SOCK_PACKET的特殊套接字类型提供对与数据链路的访问）

~~~(空)
        应用层协议
    HTTP / DNS / RTP / ...
                │
                ▼
       传输层协议 (L4)
   TCP ←——→ UDP ←——→ SCTP
      │          │
      ▼          ▼
       网络层 (L3) 核心承载
    +----------------------+
    |   IPv4   |   IPv6    |
    |----------+-----------|
    | ICMP     | ICMPv6    |
    | IGMP     | ND/SLAAC  |
    +----------------------+
        │            │
   (IPv4依赖ARP)   (IPv6依赖ND)
        ▼            ▼
+------------------------------+
| 数据链路层 (L2)               |
| ARP ↔ IPv4 地址解析           |
| RARP (旧)                    |
| DLPI (链路层 API)             |
+------------------------------+
        │
        ▼
+------------------------------+
| 物理层 (L1): 电、光、射频等     |
+------------------------------+
         ▲
         │
   BPF / eBPF（跨 L2-L4）
   Packet 捕获 / 过滤 / 观察

~~~



~~~diff
+----------------------------+
| 应用层 L7: HTTP, DNS, RTP |
+----------------------------+
| 表示层 L6: TLS, 加解密       |
+----------------------------+
| 会话层 L5: RPC, NetBIOS     |
+----------------------------+
| 传输层 L4: TCP / UDP / SCTP |
+----------------------------+
| 网络层 L3: IPv4 IPv6 ICMP   |
|          IGMP ICMPv6 ND    |
+----------------------------+
| 数据链路层 L2: ARP RARP      |
|              DLPI          |
+----------------------------+
| 物理层 L1: 电缆 光纤 信号     |
+----------------------------+
| BPF/eBPF: 跨 L2-L4 过滤监控  |
+----------------------------+

~~~



## 2.2 用户数据报协议（UDP）

略

## 2.3 传输控制协议（TCP）

略

## 2.4 流控制传输协议（SCTP）

略



## 2.5 TCP连接的建立和终止

### 2.5.1 TCP连接的建立

TCP的**建立**需要通过“三次握手”，过程如下：

-----

1. **第一次握手**：客户端 → 服务器（SYN）

> * 客户端发送一个 `SYN` 包（同步序列号）
> * 指明客户端的初始序列号：`SEQ = x`
> * 客户端进入 **SYN_SENT** 状态

**作用：** 告诉服务器“我要连接你，并以序号 x 作为起点”。

2. **第二次握手**：服务器 → 客户端（SYN + ACK）

> * 服务器收到 SYN 后，回复：
>
>   - `SYN`（告诉客户端：我也要建立连接）
>
>   - `ACK`（确认客户端的 SYN）
>
>     *  确认号：`ACK = x + 1`
>*  服务器的初始序列号：`SEQ = y`
> *  服务器进入 **SYN_RCVD** 状态

**作用：**告诉客户端“我收到了你的请求，我也愿意建立连接，序号从 y 开始”。

3. **第三次握手**：客户端 → 服务器（ACK）

> * 客户端收到服务器的 SYN+ACK 后，回复：
>
>   - `ACK = y + 1`
>
>   - `SEQ = x + 1`
>
> * 客户端进入 **ESTABLISHED 已建立连接**
>
> * 服务器收到 ACK 后也进入 **ESTABLISHED**

**作用：**客户端确认“连接建立成功”，服务器收到后正式进入连接状态。

---------

**带状态的变化图**：

~~~
           Client                                      Server
   ------------------                           -------------------
   状态: CLOSED                                   状态: LISTEN
        |                                               |
        | 1. SYN (SEQ=x)                                |
        |---------------------------------------------->|
        |                                               |
   状态: SYN_SENT                                 状态: SYN_RCVD
        | 2. SYN + ACK (SEQ=y, ACK=x+1)                 |
        |<----------------------------------------------|
        |                                               |
        | 3. ACK (ACK=y+1)                               |
        |---------------------------------------------->|
        |                                               |
   状态: ESTABLISHED                             状态: ESTABLISHED

~~~



### 2.5.2 TCP连接的终止

TCP 是全双工连接 —— 每一方都必须显式关闭自己的发送方向，因此关闭连接需要 **四次挥手**。

----------

1.  **FIN（主动关闭方 → 被动关闭方）**：主动关闭方（如客户端）发送

~~~(空)
FIN = 1, seq = u
~~~

表示：我已经没有数据要发了，但还能接收数据。被动关闭方进入 `CLOSE_WAIT` 状态。

2. **ACK（被动关闭方 → 主动关闭方）**：被动关闭方回复

~~~(空)
ACK = 1, ack = u + 1
~~~

表示：我知道你要关闭发送方向了。主动关闭方进入 `FIN_WAIT_2` 状态。

3. FIN（被动关闭方 → 主动关闭方）：当被动关闭方数据发送完毕后，也发送

~~~(空)
FIN = 1, seq = v
~~~

表示：我数据发完了，也要关闭了。被动关闭方进入 `LAST_ACK` 状态。

4. ACK（主动关闭方 → 被动关闭方）：主动关闭方回复

~~~(空)
ACK = 1, ack = v + 1
~~~

主动关闭方进入 `TIME_WAIT`（保持 2MSL），保证对方收到 ACK。

被动关闭方收到 ACK 后进入 `CLOSED` 状态。

-----------------------

**带状态的变化图**：

~~~(空)
主动关闭方 (Client)                               被动关闭方 (Server)
-----------------------                           ------------------------

    ESTABLISHED                                         ESTABLISHED
         |                                                    |
         | ----- FIN, seq=u --------------------------------> |
         |                                                    |
         | <---- ACK, ack=u+1 ------------------------------- |
         |                                                    |
    FIN_WAIT_2                                         CLOSE_WAIT
         |                                                    |
         |                          （Server 继续发送数据）    |
         |                                                    |
         | <---- FIN, seq=v --------------------------------- |
         |                                                    |
         | ----- ACK, ack=v+1 ------------------------------> |
         |                                                    |
    TIME_WAIT                                            LAST_ACK
       (等待 2MSL)                                            |
         |                                                    |
         |                                                    |
    CLOSED                                                CLOSED

~~~



### 2.5.3 TCP状态转移图

这是 TCP 的所有关键状态：
 `CLOSED → LISTEN → SYN_RCVD → ESTABLISHED → FIN_WAIT_1 → FIN_WAIT_2 → TIME_WAIT → CLOSED`
 以及服务器端的 `CLOSE_WAIT`、`LAST_ACK`。

TCP 状态机：

~~~mermaid
%%{init: {'theme':'forest', 'wrap': true}}%%
stateDiagram-v2
    direction TB

    %% === 建立阶段（蓝色）===
    [*] --> CLOSED
    CLOSED --> LISTEN: Passive Open
    CLOSED --> SYN_SENT: Active Open (send SYN)
    LISTEN --> SYN_RCVD: rcv SYN
    LISTEN --> SYN_SENT: send SYN (Simultaneous Open)
    SYN_SENT --> SYN_RCVD: rcv SYN
    SYN_SENT --> ESTABLISHED: rcv SYN+ACK<br>send ACK
    SYN_RCVD --> ESTABLISHED: rcv ACK

    %% === 数据阶段（绿色）===
    ESTABLISHED --> FIN_WAIT_1: close()<br>send FIN
    ESTABLISHED --> CLOSE_WAIT: rcv FIN<br>send ACK

    %% === 主动关闭阶段（橙色）===
    FIN_WAIT_1 --> FIN_WAIT_2: rcv ACK
    FIN_WAIT_1 --> CLOSING: rcv FIN+ACK
    FIN_WAIT_2 --> TIME_WAIT: rcv FIN<br>send ACK
    CLOSING --> TIME_WAIT: rcv ACK
    TIME_WAIT --> CLOSED: timeout (2MSL)

    %% === 被动关闭阶段（红色）===
    CLOSE_WAIT --> LAST_ACK: send FIN
    LAST_ACK --> CLOSED: rcv ACK

    %% === 样式 ===
    style CLOSED fill:#ffffff,stroke:#333,color:#000
    style LISTEN fill:#a0c4ff,stroke:#333,color:#000
    style SYN_SENT fill:#a0c4ff,stroke:#333,color:#000
    style SYN_RCVD fill:#a0c4ff,stroke:#333,color:#000
    style ESTABLISHED fill:#32cd32,stroke:#333,color:#000
    style FIN_WAIT_1 fill:#ffa500,stroke:#333,color:#000
    style FIN_WAIT_2 fill:#ffa500,stroke:#333,color:#000
    style CLOSING fill:#ffa500,stroke:#333,color:#000
    style TIME_WAIT fill:#ffa500,stroke:#333,color:#000
    style CLOSE_WAIT fill:#ff6347,stroke:#333,color:#000
    style LAST_ACK fill:#ff6347,stroke:#333,color:#000

~~~

图示：

![](./images/TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%9B%BE.png)

### 2.5.4 观察分组

下图展示了一个完整的TCP链接所发生的实际分组交换的情况，包括连接建立、数据传送和连接终止三个阶段。示例中的酷虎通告一个值为536的MSS（表明该客户只实现了最小重组缓冲区大小），服务器通告一个值为1460的MSS（以太网上IPv4的典型值），不同方向上MSS值不相同不成问题。

~~~(空)
Client A                              Server B
 (SYN_SENT)                            (LISTEN)
   |                                     |
   |  A -> B: [SYN, seq=x, MSS=536]      |
   |------------------------------------>|
   |                                     | (SYN_RCVD)
   |  A <- B: [SYN,ACK, seq=y, ack=x+1, MSS=1460]  |
   |<------------------------------------|
   |   (ESTABLISHED)                     |
   |  A -> B: [ACK, ack=y+1]             |
   |------------------------------------>|
   |                                     | (ESTABLISHED)
   |                                     |
   |---------- application data -------->|
   |  A -> B: [PSH,ACK, seq=x+1, ack=y+1, len=100]   (1)|
   |------------------------------------>|
   |  A <- B: [ACK, ack=x+1+100]         |
   |<------------------------------------|
   |                                     |
   |  A -> B: [PSH,ACK, seq=x+1+100, ack=y+1, len=200] (2)|
   |------------------------------------>|
   |  A <- B: [ACK, ack=x+1+100+200]     |
   |<------------------------------------|
   |                                     |
   |  (主动关闭) A -> B: [FIN,ACK, seq=xa, ack=yb]  |
   |------------------------------------>|
   |   A: FIN_WAIT_1                     |
   |                                     |  B: (CLOSE_WAIT)
   |  A <- B: [ACK, ack=xa+1]            |
   |<------------------------------------|
   |   A: FIN_WAIT_2                     |
   |                                     |
   |  B -> A: [FIN, seq=yb, ack=xa+1]    |
   |<------------------------------------|
   |  A -> B: [ACK, ack=yb+1]            |
   |------------------------------------>|
   |   A: TIME_WAIT (wait 2*MSL)         |
   |   then -> CLOSED                    |
   |                                     |  B: LAST_ACK -> CLOSED

~~~

> **关键点说明（对应上图）**
>
> 1. **三次握手**
>    - A 发 `SYN (seq=x)` → 状态：`SYN_SENT`。
>    - B 收到后回 `SYN+ACK (seq=y, ack=x+1)` → 状态：`SYN_RCVD`。
>    - A 回 `ACK (ack=y+1)`，双方进入 `ESTABLISHED`。
> 2. **数据传输**
>    - 数据段带 `seq`（字节流中的位置）和 `len`（有效载荷长度）。
>    - 接收方用 `ACK` 报文确认：`ack = seq + len`（逐字节确认）。
>    - 可见带 `PSH` 表示推送、常与 ACK 一起出现（实现上并非必须）。
> 3. **连接关闭（主动端 A）——四次挥手**
>    - A 发送 `FIN,ACK`：告诉 B 我这边已没有更多数据要发。A 进入 `FIN_WAIT_1`。
>    - B 返回 `ACK` 确认 A 的 FIN，A 进入 `FIN_WAIT_2`，B 进入 `CLOSE_WAIT`（可以先交付给应用并等待本地关闭）。
>    - B 发送自己的 `FIN`（在本地应用关闭后），A 收到后回复 `ACK`。
>    - A 进入 `TIME_WAIT`（保持一段时间，通常 2*MSL），之后最终进入 `CLOSED`。B 在发送 `FIN` 后等待 `ACK`，收到后进入 `CLOSED`（或 `LAST_ACK` -> `CLOSED`）。
>
> **简要状态转换表（常见端）**
>
> - 客户端（主动发起关闭）典型序列：
>   - `CLOSED -> SYN_SENT -> ESTABLISHED -> FIN_WAIT_1 -> FIN_WAIT_2 -> TIME_WAIT -> CLOSED`
> - 服务器端（被动接受连接，随后被动/主动关闭）：
>   - `LISTEN -> SYN_RCVD -> ESTABLISHED -> CLOSE_WAIT -> LAST_ACK -> CLOSED`
>
> **常见标志位与含义**
>
> - `SYN`：建立连接请求（初始化 seq）。
> - `ACK`：确认字段有效（通常与确认号一起）。
> - `FIN`：告知发送端已结束发送。
> - `RST`：立即复位连接（异常、错误）。
> - `PSH`：请求接收端立即把数据交给应用（实现提示）。
> - `URG`：紧急指针字段有效（很少用）。

一旦建立一个连接，客户就构造一个请求并发送给服务器。这里我们假设该请求适合于单个TCP分节（即请求大小小于服务器通告的值为1460字节的MSS)。服务器处理该请求并发送一个应答，我们假设该应答也适合于单个分节（本例即小于536字节）。图中使用箭头表示这两个数据分节。注意，服务器对客户请求的确认是伴随其应答发送的。这种做法称为捎带（piggybacking)，它通常在服务器处理请求并产生应答的时间少于200ms时发生。如果服务器耗用更长时间，譬如说1s，那么我们将看到先是确认后是应答。（TCP数据流机理在TCPV1的第19章和第20章中详细叙述。）

图中随后展示的是终止连接的4个分节。注意，执行主动关闭的那一端（本例子中为客户）进入我们将在下一节中讨论的TIME_WAIT状态。

值得注意的是，如果该连接的整个目的仅仅是发送一个单分节的请求和接收一个单分节的应答，那么使用TCP有8个分节的开销。如果改用UDP，那么只需交换两个分组：一个承载请求，一个承载应答。然而从TCP切换到UDP将丧失TCP提供给应用进程的全部可靠性，迫使可靠服务的一大堆细节从传输层（TCP）转移到UDP应用进程。TCP提供的另一个重要特性即拥塞控制也必须由UDP应用进程来处理。尽管如此，我们仍然需要知道许多网络应用是使用UDP构建的，因为它们需要交换的数据量较少，而UDP避免了TCP连接建立和终止所需的开销。



## 2.6 TIME_WAIT 状态

TCP中有关网络编程最不容易理解的是它的TIME_WAIT状态。这个状态的持续时间是最长分节生命期（maximum segment lifetime， MSL）的两倍，简称2MSL。

任何TCP实现都必须为MSL选择一个值。RFC 1122[Braden 1989]的建议值是2分钟，不过源自Berkeley的实现传统上改用30秒这个值。这意味着TIMEWAIT状态的持续时间在1分钟到4分钟之间。MSL是任何IP数据报能够在因特网中存活的最长时间。我们知道这个时间是有限的，因为每个数据报含有一个称为跳限（hoplimit）的8位字段（见图A-1中IPv4的TTL字段和图A-2中IPv6的跳限字段），它的最大值为255。尽管这是一个跳数限制而不是真正的时间限制，我们仍然假设：具有最大跳限（255）的分组在网络中存在的时间不可能超过MSL秒。

分组在网络中“迷途”通常是路由异常的结果。某个路由器崩溃或某两个路由器之间的某个链路断开时，路由协议需花数秒钟到数分钟的时间才能稳定并找出另一条通路。在这段时间内有可能发生路由循环（路由器A把分组发送给路由器B，而B再把它们发送回A），我们关心的分组可能就此陷入这样的循环。假设迷途的分组是一个TCP分节，在它迷途期间，发送端TCP超时并重传该分组，而重传的分组却通过某条候选路径到达最终目的地。然而不久后（自迷途的分组开始其旅程起最多MSL秒以内）路由循环修复，早先迷失在这个循环中的分组最终也被送到目的地。这个原来的分组称为迷途的重复分组（lost duplicate)或漫游的重复分组（wandering duplicate)。TCP必须正确处理这些重复的分组。

TIME_WAIT状态有两个存在的理由：

> (1) 可靠地实现TCP全双工连接的终止；
>
> (2) 允许老的重复分节在网络中消逝。

第一个理由可以通过假设最终的ACK丢失了来解释。服务器将重新发送它的最终那个FIN，因此客户必须维护状态信息，以允许它重新发送最终那个ACK。要是客户不维护状态信息，它将响应以一个RST（另外一种类型的TCP分节)，该分节将被服务器解释成一个错误。如果TCP打算执行所有必要的工作以彻底终止某个连接上两个方向的数据流（即全双工关闭)，那么它必须正确处理连接终止序列4个分节中任何一个分节丢失的情况。本例子也说明了
为什么执行主动关闭的那一端是处于TIME_WAIT状态的那一端：因为可能不得不重传最终那个ACK的就是那一端。
为理解存在TIME_WAIT状态的第二个理由，我们假设在12.106.32.254的1500端口和206.168.112.219的21端口之间有一个TCP连接。我们关闭这个连接，过一段时间后在相同的IP地址和端口之间建立另一个连接。后一个连接称为前一个连接的化身（incarnation)，因为它们的IP地址和端口号都相同。TCP必须防止来自某个连接的老的重复分组在该连接已终止后再现，从而被误解成属于同一连接的某个新的化身。为做到这一点，TCP将不给处于TIME_WAIT状态的连接发起新的化身。既然TIME_WAIT状态的持续时间是MSL的2倍，这就足以让某个方向上
的分组最多存活MSL秒即被丢弃，另一个方向上的应答最多存活MSL秒也被丢弃。通过实施这个规则，我们就能保证每成功建立一个TCP连接时，来自该连接先前化身的老的重复分组都己在网络中消逝了。

> 这个规则存在一个例外：如果到达的SYN的序列号大于前一个化身的结束序列号，源自Berkeley的实现将给当前处于TIME_WAIT状态的连接启动新的化身。TCPv2第958~959页对这种情况有详细的叙述。它要求服务器执行主动关闭，因为接受下一个SYN的那一端必须处于TIME_WAIT状态。rsh命令具备这种能力。RFC 1185 [Jacobson, Braden, and Zhang 1990] 讲述了有关这种情形的一些陷阱。



## 2.7 SCTP 关联的建立和终止

与TCP一样，SCTP也是面向连接的，因此也有关联的建立与终止的握手过程。不过SCTP的握手过程不同于TCP。

### 2.7.1 四路握手

建立一个SCTP关联的时候会发生下述情形（类似于TCP)。

> （1）服务器必须准备好接受外来的关联。这通常通过调用socket、bind和listen这3个函数来完成，称为被动打开。 

>  （2）客户通过调用connect或者发送一个隐式打开该关联的消息进行主动打开。这使得客户SCTP发送一个INIT消息（初始化），该消息告诉服务器客户的IP地址清单、初始序列号、用于标识本关联中所有分组的起始标记、客户请求的外出流的数目以及客户能够支持的外来流的数目。

> （3）服务器以一个INITACK消息确认客户的INIT消息，其中含有服务器的IP地址清单、初始序列号、起始标记、服务器请求的外出流的数目、服务器能够支持的外来流的数目以及一个状态cookie。状态cookie包含服务器用于确信本关联有效所需的所有状态，它是数字化签名过的，以确保其有效性。

> （4）客户以一个COOKIE ECHO消息回射服务器的状态cookie。除COOKI EECHO外，该消息可能在同一个分组中还捆绑了用户数据。

> （5）服务器以一个COOKIE ACK消息确认客户回射的cookie是正确的，本关联于是建立。该消息也可能在同一个分组中还捆绑了用户数据。

以上交换过程至少需要4个分组，因此称之为SCTP的四路握手（four-way handshake)。

~~~(空)
Client A                                      Server B
( CLOSED )                                    ( CLOSED )
    |                                            |
    |  INIT                                      |
    |  [Initiate, Tag=Ta, TSN=Ia, a_rwnd]        |
    |------------------------------------------->|
    |                                            |  (收到INIT，不分配资源)
    |                                            |
    |  INIT-ACK                                  |
    |  [Init Ack, Tag=Tb, TSN=Ib, Cookie C]      |
    |<-------------------------------------------|
    |                                            |
    |  COOKIE-ECHO                               |
    |  [Echo Cookie]                             |
    |------------------------------------------->|
    |                                            |  (此时才真正分配资源)
    |                                            |  (进入 ESTABLISHED)
    |                                            |
    |  COOKIE-ACK                                |
    |  [Cookie Ack]                              |
    |<-------------------------------------------|
    |                                            |
( ESTABLISHED )                            ( ESTABLISHED )

~~~

| 步骤 | 报文        | 方向            | 作用                        |
| ---- | ----------- | --------------- | --------------------------- |
| 1    | INIT        | Client → Server | 请求建立 SCTP Association   |
| 2    | INIT-ACK    | Server → Client | 返回初始化参数 + **Cookie** |
| 3    | COOKIE-ECHO | Client → Server | 回显 Cookie，证明是真实主机 |
| 4    | COOKIE-ACK  | Server → Client | 确认关联建立完成            |

SCTP的四路握手在很多方面类似于TCP的三路握手，差别主要在于作为SCTP整体一部分的cookie的生成。INIT（随其众多参数一道）承载一个验证标记 Ta 和一个初始序列号 J。在关联的有效期内，验证标记 Ta 必须在对端发送的每个分组中出现。初始序列号J用作承载用户数据的DATA块的其实序列号。对端也在INIT ACK中承载一个验证标记 Tz，在关联有效期内，验证标记 Tz 也必须在其发送的每个分组中出现。除了验证标记 Tz 和初始序列号 K 外，INIT 的接收端还在作为响应的INIT ACK中提供一个cookie C。该cookie包含设置本SCTP关联所需的所有状态，这样服务器的SCTP栈就不必保存所有关联客户的信息。

四路握手过程结束时，两端各自选择一个主目的地址。当不存在 网络故障时，主目的地址将用作数据要发送到默认目的地址。在SCTP中使用四路握手是为了避免一种将在第四章中讨论的拒绝服务攻击。

>  **Cookie 机制（抗 SYN Flood）**
>
> - Server 在 **INIT-ACK 中不保存任何状态**
> - 所有连接状态 **封装进 Cookie**
> - 只有当 Client 回送 `COOKIE-ECHO`：
>   - Server 才真正分配资源
>   - 才建立 Association
>
> 这使得 SCTP **天生免疫 TCP SYN Flood 攻击**。



### 2.7.2 关联终止

**SCTP不像TCP那样允许“半关闭”的关联。当一端关闭某个关联时，另一端必须停止发送新的数据。**关联关闭请求的接收端发送完已经排队的数据（如果有的话）后，完成关联的关闭。

~~~(空)
Client A                                      Server B
( ESTABLISHED )                              ( ESTABLISHED )
      |                                            |
      |  SHUTDOWN                                  |
      |  [No more DATA, cumTSN=XA]                 |
      |------------------------------------------->|
      |   A: SHUTDOWN_SENT                         |
      |                                            |  停止接收新DATA
      |                                            |  发送完剩余数据
      |                                            |
      |  SHUTDOWN-ACK                              |
      |  [Confirm all data received]               |
      |<-------------------------------------------|
      |   A: SHUTDOWN_ACK_SENT                     |
      |                                            |
      |  SHUTDOWN-COMPLETE                         |
      |------------------------------------------->|
      |   A: CLOSED                                |
      |                                            |  B: CLOSED

~~~

SCTP没有类似于TCP的TIME_WAIT状态，因为SCTP使用了验证标记。所有后续块都在捆绑它们的SCTP分组的公共首部标记了初始的INIT块和INITACK块中作为起始标记交换的验证标记；由来自旧连接的块通过所在SCTP分组的公共首部间接携带的验证标记对于新连接来说是不正确的。因此，SCTP通过放置验证标记值就避免了TCP在TIME_WAIT状态保持整个连接的做法。



### 2.7.3 SCTP 的状态转换图

SCTP涉及关联建立和关联终止的操作可以用状态转换图（state transitiondiagram）来说明。

本状态机中从一个状态到另一个状态的转换由SCTP规则基于当前状态及在该状态下所接收的块规定。举例来说，当某个应用进程在CLOSED状态下执行主动打开时，SCTP将发送一个INIT，且新的状态是COOKIE-WAIT。如果这个SCTP接着接收到一个INITACK，它将发送一个COOKIEECHO，且新的状态是COOKIE-ECHOED。如果该SCTP随后接收到一个COOKIEACK，它将转换成ESTABLISHED状态。这个最终状态是绝大多数数据传送发生点的状态，尽管DATA块也可以由COOKIEECHO块或COOKIEACK块所在消息捆绑捎带。

~~~mermaid
stateDiagram-v2
    [*] --> CLOSED

    %% ========== 建立阶段（四路握手） ==========
    CLOSED --> COOKIE_WAIT: send INIT
    COOKIE_WAIT --> COOKIE_ECHOED: recv INIT-ACK (Cookie)
    COOKIE_ECHOED --> ESTABLISHED: send COOKIE-ECHO / recv COOKIE-ACK

    %% ========== 关闭阶段（优雅关闭） ==========
    ESTABLISHED --> SHUTDOWN_SENT: send SHUTDOWN
    SHUTDOWN_SENT --> SHUTDOWN_ACK_SENT: recv SHUTDOWN-ACK
    SHUTDOWN_ACK_SENT --> CLOSED: send SHUTDOWN-COMPLETE

    ESTABLISHED --> SHUTDOWN_RECEIVED: recv SHUTDOWN
    SHUTDOWN_RECEIVED --> SHUTDOWN_ACK_SENT: send SHUTDOWN-ACK
    SHUTDOWN_ACK_SENT --> CLOSED: recv SHUTDOWN-COMPLETE

    %% ========== 异常关闭 ==========
    ESTABLISHED --> CLOSED: ABORT
    COOKIE_ECHOED --> CLOSED: ABORT / bad cookie

~~~

### 2.7.4 SCTP 选项

SCTP使用参数和块方便增设可选特性。新的特性通过添加这两个条目之一加以定义，并允许通常的SCTP处理规则汇报未知的参数和未知的块。参数类型字段和块类型字段的高两位指明SCTP接收端该如何处置未知的参数或未知的块（[Stewart andXie 2001]的3.1节给出了更多的细节）。当前如下两个对SCTP的扩展正在开发中。

（1）动态地址扩展，允许协作的SCTP端点从已有的某个关联中动态增删IP地址。

（2）不完全可靠性扩展，允许协作的SCTP端点在应用进程的指导下限制数据的重传。当一个消息变得过于陈旧而无须发送时（按照应用进程的指导），该消息将被跳过而不再发送到对端。这意味着不是所有数据都确保到达关联的另一端。



## 2.8 端口号

任何时候，多个进程可能同时使用TCP、UDP和SCTP这3种传输层协议中的任何一种。这3种协议都使用16位整数的端口号（port number）来区分这些进程。

当一个客户想要跟一个服务器联系时，它必须标识想要与之通信的这个服务器。TCP、UDP和SCTP定义了一组众所周知的端口（well-knownport)，用于标识众所周知的服务。举例来说，支持FTP的任何TCP/IP实现都把21这个众所周知的端口分配给FTP服务器。分配给简化文件传送协议（Trivial FileTrqnsfer Protocol，TFTP)的是UDP端口号69。

另一方面，客户通常使用短期存活的临时端口（ephemeralport)。这些端口号通常由传输层协议自动赋予客户。客户通常不关心其临时端口的具体值，而只需确信该端口在所在主机中是唯一的就行。传输协议的代码确保这种唯一性。

IANA（the Internet Assigned Numbers Authority，因特网已分配数值权威机构）维护着一个端口号分配状况的清单。该清单一度作为RFC多次发布：RFC1700[Reynolds and Postel 1994]是这个系列的最后一个。RFC3232 [Reynolds 2002] 给出了替代 RFC1700 的在线数据库的位置：http://www.iana.org/。端口号被划分成以下3段。

1. 众所周知的端口为0~1023。这些端口由IANA分配和控制。可能的话，相同端口号就分配给TCP、UDP和SCTP的同一给定服务。例如，不论TCP还是UDP端口号80都被赋予Web服务器，尽管它目前的所有实现都单纯使用TCP。

   > 端口号80分配时SCTP尚不存在。新的端口分配将针对这3种协议执行，RFC2960则声明所有现有的TCP端口号对于使用SCTP的同一服务同样有效。

2. 已登记的端口(registered port）为1024\~49151。这些端口不受IANA控制，不过由IANA登记并提供它们的使用情况清单，以方便整个群体。可能的话，相同端口号也分配给TCP和UDP的同一给定服务。例如，6000\~6063分配给这两种协议的XWindow服务器，尽管它的所有实现当前单纯使用TCP。49151这个上限的引I入是为了给临时端口留出范围，而RFC1700 [Reynoldsand Postel 1994]所列的上限为65535。
3. 49152\~65535是动态的（dynamic）或私用的（private）端口。IANA不管这些端口。它们就是我们所称的临时端口。（49152这个魔数是65536的四分之三。）

|    区间     | 名称                | 是否可被 OS 自动分配 | 典型用途                                   |
| :---------: | ------------------- | -------------------- | ------------------------------------------ |
|   0–1023    | Well-Known          | ❌ 禁止               | HTTP(80)、HTTPS(443)、SSH(22)、FTP(21)     |
| 1024–49151  | Registered          | ⚠️ 可配置             | MySQL(3306)、Redis(6379)、PostgreSQL(5432) |
| 49152–65535 | Dynamic / Ephemeral | ✅ 默认               | 客户端临时端口                             |

~~~(空)
端口号范围：0 ────────────────────────────────────────────────► 65535

┌───────────────┬─────────────────────────────────┬───────────────────────────────┐
│   0 ~ 1023    │        1024 ~ 49151             │         49152 ~ 65535         │
│ Well-Known    │        Registered               │     Dynamic / Ephemeral       │
│ 知名端口       │         注册端口                  │         动态 / 临时端口         │
└───────────────┴─────────────────────────────────┴───────────────────────────────┘

~~~

### 套接字

一个TCP连接的套接字对（socket pair）是一个定义该连接的两个端点的四元组：本地IP地址、本地TCP端口号、外地IP地址、外地TCP端口号。套接字对唯一标识一个网络上的每个TCP连接。就SCTP而言，一个关联由一组本地IP地址、一个本地端口、一组外地IP地址、一个外地端口标识。在两个端点均非多宿这一最简单的情形下，SCTP与TCP所用的四元组套接字对一致。然而在某个关联的任何一个端点为多宿的情形下，同一个关联可能需要多个四元组标识（这些四元组的IP地址各不相同，但端口号是一样的）。

标识每个端点的两个值（IP地址和端口号）通常称为一个套接字。我们可以把套接字对的概念扩展到UDP，即使UDP是无连接的。当讲解套接字函数（bind、connect、getpeername等）时，我们将指明它们在指定套接字对中的哪些值。举例来说，bind函数要求应用程序给TCP、UDP或SCTP套接字指定本地IP地址和本地端口号。



## 2.9 TCP 端口号与并发服务器

并发服务器中主服务器通过循环派生一个子进程来处理每个新的连接。如果一个子进程继续使用服务器众所周知的端口来服务一个长时间的请求，那将发生什么？

一个典型的序列：

首先，在主机freebsd上启动服务器，该主机是多宿的，其IP地址为`12.106.32.254`和`192.168.42.1`。服务器在它众所周知的端口（21端口）上执行被动打开，从而开始等待客户端的请求。

~~~(空)
                         Internet / 外网
                               |
                               |
                               | 12.106.32.254
                               |
                    +--------------------------------+
                    |                                |
                    |        FreeBSD 服务器           |
                    |        (Multi-homed Host)      |
                    |         {*:21,*:*}    ---------+------->监听套接字
                    |  网卡 eth0 : 12.106.32.254      |
                    |  网卡 eth1 : 192.168.42.1       |
                    |                                |
                    +--------------------------------+
                               |
                               | 192.168.42.1
                               |
                        内部局域网 192.168.42.0/24

~~~



我们使用记号`{*:21,*:*}`指出服务器的套接字对。服务器在任意本地接口（第一个星号）的端口21上等待连接请求。外地IP地址和外地端口都没有指定，我们用“*，*”来表示。我们称它为监听套接字(listening socket)。

> 我们用分号来分割IP地址和端口号，因为这是HTTP的用法，其他地方也常见。netstat程序使用点号来分割IP地址和端口号，不过如此表示有时候会让人混淆，因为点号既用于域名（如freebsd.unpbook.com.21)，也用于IPv4的点分十进制数记法（如12.106.32.254.21）。

这里指定本地IP地址的星号称为通配（wildcard）符。如果运行服务器的主机是多宿的（如本例），服务器可以指定它只接受到达某个特定本地接口的外来连接。这里要么选一个接口要么选任意接口。服务器不能指定一个包含多个地址的清单。通配的本地地址表示“任意”这个选择。通配地址通过在调用bind之前把套接字地址结构中的IP地址字段设置成`INADDR_ANY`来指定。

稍后在IP地址为`206.168.112.219`的主机上启动第一个客户，它对服务器的IP地址之一`12.106.32.254`执行主动打开。我们假设本例中客户主机的TCP为此选择的临时端口为1500，在图中在该客户的下方标出了它的套接字对。

~~~(空)
+------------------------------+         +--------------------------------+
|        FreeBSD 客户端         |         |        FreeBSD 服务器           |
|       206.168.112.219    ----+---------+->12.106.32.254 , 192.168.42.1  |
|   { 206.168.112.219:1500,    |         |        TCP LISTEN : 21         |
|     12.106.32.254:21  }      |         |      	{*:21,*:*}    --------+-->监听套接字
+------------------------------+         +--------------------------------+
~~~

当服务器接收并接受这个客户的连接时，它fork一个自身的副本，让子进程来处理该客户的请求。（我们将在4.7节中讲解fork函数。）至此，我们必须在服务器主机上区分监听套接字和已连接套接字（connectedsocket）。注意已连接套接字使用与监听套接字相同的本地端口（21）。还要注意在多宿服务器主机上，连接一旦建立，已连接套接字的本地地址（12.106.32.254）随即填入。

~~~(空)
客户端 206.168.112.219:1500                   FreeBSD 服务器
+---------------------------+        +---------------------------------------+
|                           |        |  父进程: 监听套接字                      |
|  {206.168.112.219:1500,   |  SYN   |  {*:21,*:*}  <---- LISTEN             |
|   12.106.32.254:21}       |------->|                                       |
|                           |<-------|  SYN+ACK                              |
|                           |  ACK   |  accept() + fork()                    |
|                           |------->|                |                      |
|                           |        |                v                      |
|                           |        |  子进程: 已连接套接字                    |
|                           |        |  {12.106.32.254:21,                   |
|                           |        |   206.168.112.219:1500}  <--- ESTABL  |
+---------------------------+        +---------------------------------------+

~~~

下一步我们假设在客户主机上另有一个客户请求连接到同一个服务器。客户主机的TCP为这个新客户的套接字分配一个未使用的临时端口，警如说1501。服务器上这两个连接是有区别的：第一个连接的套接字对和第二个连接的套接字对不一样，因为客户的TCP给第二个连接选择了一个未使用的端口（1501）。

~~~
客户端1:206.168.112.219:1500                   FreeBSD 服务器
+---------------------------+        +---------------------------------------+
|                           |   SYN  |  父进程: 监听套接字                      |
|  {206.168.112.219:1500,   |------->|  {*:21,*:*}  <---- LISTEN             |
|   12.106.32.254:21}       |<-------|                                       |
|                           |  ACK   |  SYN+ACK           SYN+ACK            |
|                           |------->|  accept() + fork() + fork()           |
+---------------------------+        |                |       |              |
客户端2:206.168.112.219:1501          |                v       |              |
+---------------------------+        |  子进程1: 已连接套接字    |              |
|                           |   SYN  |  {12.106.32.254:21,    |              |
|   {206.168.112.219:1501,  |------->|   206.168.112.219:1500}| <--- ESTABL  |
|    12.106.32.254:21}      |<-------|						  v              |
|                           |  ACK   |                子进程2: 已连接套接字 <---+-ESTABL
|                           |------->|{12.106.32.254:21,206.168.112.219:1501}|
+---------------------------+        +---------------------------------------+
~~~

通过本例应注意，TCP无法仅仅通过查看目的端口号来分离外来的分节到不同的端点。它必须查看套接字对的所有4个元素才能确定由哪个端点接收某个到达的分节。图中对于同一个本地端口（21）存在3个套接字。如果一个分节来自206.168.112.219端口1500，目的地为12.106.32.254端口21，它就被递送给第一个子进程。如果一个分节来自206.168.112.219端口1501，目的地为12.106.32.254端口21，它就被递送给第二个子进程。所有目的端口为21的其他TCP分节都被递送给拥有监听套接字的最初那个服务器（父进程)。

## 2.10 缓冲区大小及限制

下面我们将介绍一些影响IP数据报大小的限制。我们首先介绍这些限制，然后就它如何响应应用进程能够传送的数据进行综合分析。

* IPv4数据报的最大大小是65535字节，包括IPv4首部。这是因为其总长度字段占据16位。
* IPv6数据报的最大大小是65575字节，包括40字节的IPv6首部。这是因为其净荷长度字段占据16位。注意，IPv6的净荷长度字段不包括IPv6首部，而IPV4的总长度字段包括IPv4首部。[ IPv6有一个特大净荷jumbopayload 选项，它把净荷长度字段扩展到32位，不过这个选项需要MTU（maximum transmission unit，最大传输单元）超过65535的数据链路提供支持。（这是为主机到主机的内部连接而设计的，警如HIPPI，它们通常没有内在的MTU）。]
* 许多网络有一个可由硬件规定的MTU。举例来说，以太网的MTU是1500字节。另有一些链路（例如使用PPP协议的点到点链路）其MTU可以人为配置。较老的SLIP链路通常使用1006字节或296字节的MTU。IPV4要求的最小链路MTU是68字节。这允许最大的IPV4首部（包括20字节的固定长度部分和最多40字节的选项部分）拼接最小的片段（IPv4首部中片段偏移字段以8个字节为单位)。IPv6要求的最小链路MTU为1280字节。IPv6可以运行在MTU小于此最小值的链路上，不过需要特定于链路的分片和重组功能，以使得这些链路看起来具有至少为1280字节的MTU（RFC 2460[Deering and Hinden 1998])。
* 在两个主机之间的路径中最小的MTU称为路径MTU（pathMTU)。1500字节的以太网MTU是当今常见的路径MTU。两个主机之间相反的两个方向上路径MTU可以不一致，因为在因特网中路由选择往往是不对称的[Paxson1196]，也就是说从A到B的路径与从B到A的路径可以不相同。
* 当一个IP数据报将从某个接口送出时，如果它的大小超过相应链路的MTU，IPv4和IPv6都将执行分片（fragmentation）。这些片段在到达最终目的地之前通常不会被重组（reassembling)。IPv4主机对其产生的数据报执行分片，IPv4路由器则对其转发的数据报执行分片。然而IPv6只有主机对其产生的数据报执行分片，IPv6路由器不对其转发的数据报执行分片。
* IPv4首部的“不分片（don't fragment)”位（即DF位）若被设置，那么不管是发送这些数据报的主机还是转发它们的路由器，都不允许对它们分片。当路由器接收到一个超过其外出链路MTU大小且设置了DF位的IPv4数据报时，它将产生一个ICMPv4“destination unreachable,fragmentation needed but DF bit set”（目的地不可达,需分片但DF位已设置）出错消息。既然IPv6路由器不执行分片，每个IPv6数据报于是隐含一个DF位。当IPv6路由器接收到一个超过其外出链路MTU大小的IPv6数据报时，它将产生一个ICMPv6“packet too big’
  （分组太大）出错消息。IPv4的DF位和IPv6的隐含DF位可用于路径MTU发现（IPv4的情形见RFC1191[Mogul
  and Deering1990]，IPv6的情形见RFC1981[McCann, Deering,and Mogul 1996])。举例来说，如果基于IPV4的TCP使用该技术，那么它将在所发送的所有数据报中设置DF位。如果某个中间路由器返回一个ICMP“destination unreachable,fragmentation needed butDFbitset”错误，TCP就减小每个数据报的数据量并重传。路径MTU发现对于IPv4是可选的，然而IPv6的所有实现要么必须支持它，要么必须总是使用最小的MTU发送IPv6数据报。
* IPv4和IPv6都定义了最小重组缓冲区大小（minimum reassemblybuffersize)，它是IPv4或IPv6的任何实现都必须保证支持的最小数据报大小。其值对于IPv4为576字节，对于IPv6为1500字节。例如，就IPv4而言，我们不能判定某个给定目的地能否接受577字节的数据报。为此有许多使用UDP的IPV4网络应用（如DNS、RIP、TFTP、BOOTP、SNMP）避免产生大于这个大小的数据报。
* TCP有一个MSS（maximum segment size，最大分节大小)，用于向对端TCP通告对端在每个分节中能发送的最大TCP数据量。在图2-5中我们看到过SYN分节上的MSS选项。MSS的目的是告诉对端其重组缓冲区大小的实际值，从而试图避免分片。MSS经常设置成MTU减去IP和TCP首部的固定长度。在以太网中使用IPV4的MSS值为1460，使用IPV6的MSS值为1440（两者的TCP首部都是20个字节，但IPv4首部是20字节，IPV6首部却是40字节）。在TCP的MSS选项中，MSS值是一个16位的字段，限定其最大值为65535。这对于IPv4是适合的，因为IPv4数据报中的最大TCP数据量为65495（65535减去IPv4首部的20字节和TCP首部的20字节）。然而对于具有特大净荷选项的IPV6，却需要使用另外一种技巧(RFC2675[Borman,Deering,and Hinden 1999])。首先，没有特大净荷选项的IPv6数据报中的最大TCP数据量为65515（65535减去TCP首部的20字节)。65535这个MSS值于是被视为表示“无限”的一个特殊值。该值只在用到特大净荷选项时才使用，不过这种情况却要求实际的MTU超过65535。其次，如果TCP使用特大净荷选项，并且接收到的对端通告的MSS为65535，那么它所发送数据报的大小限制就是接口MTU。如果这个值太大（也就是说所在路径中某个链路的MTU比较小)，那么路径MTU发现功能将确定这个较小值。
* SCTP基于到对端所有地址发现的最小路径MTU保持一个分片点。这个最小MTU大小用于把较大的用户消息分割成较小的能够以单个IP数据报发送的若干片段。SCTP_MAXSEG套接字选项可以影响该值，使得用户能够请求一个更小的分片点。



### 2.10.1 TCP 输出

下图展示了某个应用进程写数据到一个TCP套接字中时发生的步骤。

每一个TCP套接字有一个发送缓冲区，我们可以使用SO_SNDBUF套接字选项来更改该缓冲区的大小。当某个应用进程调用write时，内核从该应用进程的缓冲区中复制所有数据到所写套接字的发送缓冲区。如果该套接字的发送缓冲区容不下该应用进程的所有数据（或是应用进程的缓冲区大于套接字的发送缓冲区，或是套接字的发送缓冲区中已有其他数据），该应用进程将被投入睡眠。这里假设该套接字是阻塞的，它是通常的默认设置。（我们将在第16章中阐述非阻塞的套接字。）内核将不从write系统调用返回，直到应用进程缓冲区中的所有数据都复制到套接字发送缓冲区。因此，从写一个TCP套接字的write调用成功返回仅仅表示我们可以重新使用原来的应用进程缓冲区，并不表明对端的TCP或应用进程已接收到数据。（我们将在SO_LINGER套接字选项详细讨论这一点。）

~~~(空)
┌──────────────────────────────────────────┐            应用进程  
│             用户态 (User Space)           │              |
│                                          │              |  write(fd, buf, len)
│  应用进程                                 │              | 
│  buf[ ]  (用户缓冲区)                      │             v
│                                          │            进入内核 sys_write
│  write(fd, buf, len)  =================> │ 系统调用      |
└──────────────────────────────────────────┘              | copy_from_user()
                    │  拷贝 (copy_from_user)               |    用户缓冲区     
                    |                                     | ──复制──> Socket 发送缓冲区
                    ▼                                     v
┌──────────────────────────────────────────┐             Socket 层
│              内核态 (Kernel Space)        │              |
│                                          │              | 检查 SO_SNDBUF 是否有空间
│  Socket 发送缓冲区 (SO_SNDBUF)             │              |    - 满 → 进程睡眠
│  ┌───────────────────────────────────┐   │              |    - 有空闲 → 继续
│  │   sk->sk_sndbuf                   │   │              |
│  │   等待发送的数据队列                 │   │              v
│  └───────────────────────────────────┘   │             TCP 层
│                    │                     │             |
│                    ▼ TCP 分段 (MSS)       │             | 数据按 MSS 分段
│  TCP 发送队列 (Send Queue / Write Queue)  │              |    生成 skb
│  ┌───────────────────────────────────┐   │              |
│  │   skb1 | skb2 | skb3 | ...        │   │              | skb 进入 TCP 发送队列 
│  └───────────────────────────────────┘   │              | (write_queue)
│                    │                     │              |
│                    ▼  受发送窗口控制       │               | 如果发送窗口允许
│  TCP 重传队列 (Retransmission Queue)      │               |  → skb 进入重传队列
│  ┌───────────────────────────────────┐   │              | → 调用tcp_transmit_skb()
│  │   未被 ACK 确认的 skb               │   │              |
│  └───────────────────────────────────┘   │              v
│                    │                     │             IP 层
│                    ▼                     │              |
│              IP 层 (ip_output)           │              | 封装 IP 头
│                    │                     │              |
│                    ▼                     │              v
│              网卡发送队列 (qdisc)          │             网卡驱动
│                    │                     │              |
│                    ▼                     │              | skb 进入网卡发送队列
│                 网卡 → 物理链路            │              |   (tx queue)
└──────────────────────────────────────────┘              v
                                                       物理链路发出

~~~

这一端的TCP提取套接字发送缓冲区中的数据并把它发送给对端TCP，其过程基于TCP数据传送的所有规则（TCPV1的第19章和第20章)。对端TCP必须确认收到的数据，伴随来自对端的ACK的不断到达，本端TCP至此才能从套接字发送缓冲区中丢弃已确认的数据。TCP必须为已发送的数据保留一个副本，直到它被对端确认为止。

~~~(空)
用户缓冲区                内核 Socket 发送缓冲区
+------------+            +----------------------+
| buf[4096]  | --拷贝-->   |  sk_sndbuf          |
+------------+            |  等待TCP处理的数据     |
                          +----------+-----------+
                                     |
                                     v
                          TCP 发送队列 (按MSS分段)
                          +----------------------+
                          | skb | skb | skb ...  |
                          +----------+-----------+
                                     |
                                     v
                          TCP 重传队列 (等待ACK)
                          +----------------------+
                          | skb | skb | skb ...  |
                          +----------------------+

~~~

本端TCP以MSS大小的或更小的块把数据传递给IP，同时给每个数据块安上一个TCP首部以构成TCP分节，其中MSS或是由对端通告的值，或是536（若对端未发送一个MSS选项)。（536是IPv4最小重组缓冲区字节数576减去IPv4首部字节数20和TCP首部字节数20的结果。)IP给每个TCP分节安上一个IP首部以构成IP数据报，并按照其目的IP地址查找路由表项以确定外出接口，然后把数据报传递给相应的数据链路。IP可能在把数据报传递给数据链路之前将其分片，不过我们已经谈到MSS选项的目的之一就是试图避免分片，较新的实现还使用了路径MTU发现功
能。每个数据链路都有一个输出队列，如果该队列已满，那么新到的分组将被丢弃，并沿协议栈向上返回一个错误：从数据链路到IP，再从IP到TCP。TCP将注意到这个错误，并在以后某个时刻重传相应的分节。应用进程并不知道这种暂时的情况。



### 2.10.2 UDP 输出

下图展示了某个应用进程写数据到一个UDP套接字中时发生的步骤。

这一次我们以虚线框展示套接字发送缓冲区，因为它实际上并不存在。任何UDP套接字都有发送缓冲区大小（我们可以使用SO_SNDBUF套接字选项更改它)，不过它仅仅是可写到该套接字的UDP数据报的大小上限。如果一个应用进程写一个大于套接字发送缓冲区大小的数据报，内核将返回该进程一个EMSGSIZE错误。既然UDP是不可靠的，它不必保存应用进程数据的一个副本，因此无需一个真正的发送缓冲区。（应用进程的数据在沿协议栈向下传递时，通常被复制到某种格式的一个内核缓冲区中，然而当该数据被发送之后，这个副本就被数据链路层丢弃了。）

~~~(空)
┌──────────────────────────────────────────────┐
│              用户态 (User Space)              │
│                                              │
│  应用进程                                     │
│  buf[ ]   (用户缓冲区)                         │
│                                              │
│  sendto() / sendmsg() / write()  ==========> │ 系统调用
└──────────────────────────────────────────────┘
                          │  拷贝 (copy_from_user)
                          ▼
┌──────────────────────────────────────────────┐
│               内核态 (Kernel Space)           │
│                                              │
│  Socket 发送缓冲区 (SO_SNDBUF)                 │
│  ┌──────────────────────────────────────┐    │
│  │  sk->sk_sndbuf                       │    │
│  │  排队的 UDP 报文                       │    │
│  └──────────────────────────────────────┘    │
│                    │                         │
│                    ▼ UDP 层封装               │
│              UDP 报文 (一条=一个数据报)         │
│                    │                         │
│                    ▼                         │
│                 IP 层                        │
│                    │                         │
│                    ▼                         │
│           网卡发送队列 (qdisc)                 │
│                    │                         │
│                    ▼                         │
│                网卡 → 物理链路                 │
└──────────────────────────────────────────────┘

~~~

这一端的UDP简单地给来自用户的数据报安上它的8字节的首部以构成UDP数据报，然后传递给IP。IPV4或IPv6给UDP数据报安上相应的IP首部以构成IP数据报，执行路由操作确定外出接口，然后或者直接把数据报加入数据链路层输出队列（如果适合于MTU)，或者分片后再把每个片段加入数据链路层的输出队列。如果某个UDP应用进程发送大数据报（警如说2000字节的数据报)，那么它们相比TCP应用数据更有可能被分片，因为TCP会把应用数据划分成MSS大小的块，而UDP却没有对等的手段。

~~~(空)
应用进程
  |
  |  sendto(fd, buf, len, ...)
  |
  v
进入内核 sys_sendto
  |
  |  copy_from_user()
  |    用户缓冲区 ─────复制─────> Socket 发送缓冲区
  |
  v
Socket 层
  |
  |  检查 SO_SNDBUF 是否有空间
  |    - 满 → 进程睡眠 或 返回 EWOULDBLOCK
  |    - 有空闲 → 继续
  |
  v
UDP 层
  |
  |  为“这个数据报”创建 skb
  |    一个 sendto = 一个完整 UDP 报文
  |
  |  封装 UDP 头 (端口号、长度、校验和)
  |
  v
IP 层
  |
  |  封装 IP 头
  |
  |  路由查找
  |
  v
网卡驱动
  |
  |  skb 进入 网卡发送队列 (tx queue)
  |
  v
物理链路发出

~~~

从写一个UDP套接字的write调用成功返回表示所写的数据报或其所有片段已被加入数据链路层的输出队列。如果该队列没有足够的空间存放该数据报或它的某个片段，内核通常会返回一个ENOBUFS错误给它的应用进程。

> 不幸的是，有些UDP的实现不返回这种错误，这样甚至数据报未经发送就被丢弃的情况应用进程也不知道。



### 2.10.3 SCTP 输出

略。



## 2.11 常见因特网应用的协议使用



| 传输/网络层协议    | 上层应用/协议        | 典型端口号          | 主要用途说明                             |
| ------------------ | -------------------- | ------------------- | ---------------------------------------- |
| IP                 | IP Tunnel            | 无端口              | 隧道封装（如 IP-in-IP、VPN）             |
|                    | IPsec (ESP/AH)       | 无端口              | 网络层安全加密                           |
| ------------------ | -------------------- | ------------------- | ---------------------------------------- |
| ICMP               | ping                 | 无端口              | 连通性测试（Echo 请求/应答）             |
|                    | traceroute           | 无端口              | 路由路径探测                             |
|                    | ICMP 错误报告        | 无端口              | 差错与控制消息                           |
| ------------------ | -------------------- | ------------------- | ---------------------------------------- |
| TCP                | HTTP                 | 80                  | Web 访问                                 |
|                    | HTTPS                | 443                 | 加密 Web                                 |
|                    | FTP                  | 21                  | 文件传输（控制连接）                     |
|                    | SMTP                 | 25 / 587 / 465      | 发送电子邮件                             |
|                    | POP3                 | 110 / 995           | 接收电子邮件                             |
|                    | IMAP                 | 143 / 993           | 在线邮箱访问                             |
|                    | Telnet               | 23                  | 远程终端（明文）                         |
|                    | SSH                  | 22                  | 安全远程登录                             |
|                    | SFTP                 | 22                  | 安全文件传输（基于 SSH）                 |
|                    | MySQL                | 3306                | 数据库访问                               |
|                    | Redis                | 6379                | 内存数据库访问                           |
| ------------------ | -------------------- | ------------------- | ---------------------------------------- |
| UDP                | DNS                  | 53                  | 域名解析（普通查询）                     |
|                    | TFTP                 | 69                  | 简单文件传输                             |
|                    | DHCP                 | 67 / 68             | 动态地址分配                             |
|                    | SNMP                 | 161 / 162           | 网络管理与 Trap                          |
|                    | NTP                  | 123                 | 网络时间同步                             |
|                    | RIP                  | 520                 | 路由信息协议                             |
|                    | RTP                  | 动态                | 实时音视频流                             |
|                    | SIP                  | 5060 / 5061         | VoIP 呼叫控制                            |
|                    | QUIC                 | 443                 | 新型传输协议（HTTP/3 基于 UDP）          |
| ------------------ | -------------------- | ------------------- | ---------------------------------------- |
| SCTP               | SCTP 信令传输        | 2905                | 电信信令（SS7 over IP）                  |
|                    | Diameter             | 3868                | LTE/5G 核心网认证计费                    |
|                    | WebRTC DataChannel   | 动态                | 点对点可靠/半可靠数据传输                |



# END

